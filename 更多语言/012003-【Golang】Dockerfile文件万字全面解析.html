

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>【Golang】Dockerfile文件万字全面解析 &mdash; 测试开发体系 latest documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/js/readmore.js"></script>
        <script src="../_static/js/baidutongji.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="【UI自动化】webdriver使用已打开过的chrome" href="013001-%E3%80%90UI%E8%87%AA%E5%8A%A8%E5%8C%96%E3%80%91webdriver%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E8%BF%87%E7%9A%84chrome.html" />
    <link rel="prev" title="【Golang】多线程简单斗地主" href="012002-%E3%80%90Golang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E6%96%97%E5%9C%B0%E4%B8%BB.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> 测试开发体系
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6.html">关于本书</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html">编程语言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.html">测试工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6.html">测试框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83.html">测试环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html">单元测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html">白盒测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95.html">接口测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%95%8C%E9%9D%A2%E6%B5%8B%E8%AF%95.html">界面测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.html">测试报告</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html">开发框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html">消息队列</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98.html">算法挑战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86.html">技术知识</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../chapters/%E6%9B%B4%E5%A4%9A%E8%AF%AD%E8%A8%80.html">更多语言</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="000001-%E3%80%90%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.html">【开源框架】关键字驱动框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="000002-%E3%80%90%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E3%80%91%E6%A1%86%E6%9E%B6V2.0.0%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html">【开源框架】框架V2.0.0开发指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="001001-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91pytest%E5%86%85%E6%A0%B8%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E8%90%BD%E5%9C%B0%E5%88%9D%E4%BD%93%E9%AA%8C.html">【开源平台】pytest内核测试平台落地初体验</a></li>
<li class="toctree-l2"><a class="reference internal" href="001002-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91%E5%AD%A6%E4%B9%A0%E7%89%88pytest%E5%86%85%E6%A0%B8%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%85%A5%E9%97%A8%E7%AF%87.html">【开源平台】学习版pytest内核测试平台开发万字长文入门篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="001003-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E5%88%B0Linux%E7%B3%BB%E7%BB%9FDocker.html">【开源平台】teprunner测试平台部署到Linux系统Docker</a></li>
<li class="toctree-l2"><a class="reference internal" href="001004-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%94%A8%E4%BE%8B%E5%89%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91.html">【开源平台】teprunner测试平台用例前置模块开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="001005-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%94%A8%E4%BE%8B%E7%AE%A1%E7%90%86%E4%B8%8D%E5%8F%AA%E6%9C%89%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5.html">【开源平台】teprunner测试平台开发用例管理不只有增删改查</a></li>
<li class="toctree-l2"><a class="reference internal" href="001006-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0Django%E5%BC%95%E5%85%A5pytest%E5%AE%8C%E6%95%B4%E6%BA%90%E7%A0%81.html">【开源平台】teprunner测试平台Django引入pytest完整源码</a></li>
<li class="toctree-l2"><a class="reference internal" href="001007-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E7%94%A8%E4%BE%8B.html">【开源平台】teprunner测试平台测试计划批量运行用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="001008-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99%E7%AD%89%E4%BD%93%E9%AA%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8D%87%E7%BA%A7.html">【开源平台】teprunner测试平台用例编写等体验响应式升级</a></li>
<li class="toctree-l2"><a class="reference internal" href="001009-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%BF%99%E6%AC%A1%E7%BB%88%E4%BA%8E%E7%A8%B3%E4%BA%86.html">【开源平台】teprunner测试平台定时任务这次终于稳了</a></li>
<li class="toctree-l2"><a class="reference internal" href="001010-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E9%87%8D%E7%A3%85%E6%9B%B4%E6%96%B0Git%E6%89%93%E9%80%9APyCharm%E4%B8%8E%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0.html">【开源平台】teprunner重磅更新Git打通PyCharm与测试平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="001011-%E3%80%90%E5%BC%80%E6%BA%90%E5%B9%B3%E5%8F%B0%E3%80%91teprunner%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E5%85%A5%E9%97%A8%E7%BA%A7%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C%E5%8F%91%E5%B8%83%E5%95%A6.html">【开源平台】teprunner测试平台入门级部署手册发布啦</a></li>
<li class="toctree-l2"><a class="reference internal" href="002001-%E3%80%90Python%E3%80%91%E5%A6%82%E4%BD%95%E8%AE%A9%E6%96%87%E7%A7%91%E7%94%9F5%E5%88%86%E9%92%9F%E5%86%99%E4%B8%8APython.html">【Python】如何让文科生5分钟写上Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="002002-%E3%80%90Python%E3%80%91%E7%9C%9F%E9%A6%99%EF%BC%8C%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BF%86%E6%B3%95%E5%AD%A6%E4%B9%A0Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html">【Python】真香，理解记忆法学习Python基础语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="002003-%E3%80%90Python%E3%80%91%E7%94%A8PyCharm%E6%89%93%E4%B8%AA%E4%B8%93%E4%B8%9A%E7%9A%84%E6%8B%9B%E5%91%BC.html">【Python】用PyCharm打个专业的招呼</a></li>
<li class="toctree-l2"><a class="reference internal" href="002004-%E3%80%90Python%E3%80%91Python%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%AF%E4%B8%8D%E5%8F%AA%E6%9C%89%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4.html">【Python】Python运算符可不只有加减乘除</a></li>
<li class="toctree-l2"><a class="reference internal" href="002005-%E3%80%90Python%E3%80%91%E4%BD%A0%E7%9F%A5%E9%81%93Python%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%93%AA6%E4%B8%AA%E4%B9%88.html">【Python】你知道Python基本数据类型是哪6个么</a></li>
<li class="toctree-l2"><a class="reference internal" href="002006-%E3%80%90Python%E3%80%91%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E7%BB%84%E6%88%90%E4%BA%86Python%E4%BB%A3%E7%A0%81%E7%9A%84%E9%AA%A8%E6%9E%B6.html">【Python】条件循环语句组成了Python代码的骨架</a></li>
<li class="toctree-l2"><a class="reference internal" href="002007-%E3%80%90Python%E3%80%91%E4%BB%8E%E5%87%BD%E6%95%B0%E5%88%B0%E5%8C%85%E7%9A%84Python%E4%BB%A3%E7%A0%81%E5%B1%82%E6%AC%A1.html">【Python】从函数到包的Python代码层次</a></li>
<li class="toctree-l2"><a class="reference internal" href="002008-%E3%80%90Python%E3%80%91%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%8E%A8%E5%BC%80Python%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E5%A4%A7%E9%97%A8.html">【Python】魔法方法推开Python进阶学习大门</a></li>
<li class="toctree-l2"><a class="reference internal" href="002009-%E3%80%90Python%E3%80%91Python%E9%AA%9A%E6%93%8D%E4%BD%9C%E4%BB%8E%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%A7%8B.html">【Python】Python骚操作从列表推导和生成器表达式开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="002010-%E3%80%90Python%E3%80%91Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8EPython%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">【Python】Python数据模型与Python对象模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="002011-%E3%80%90Python%E3%80%91Python%E5%85%83%E7%BB%84%E6%8B%86%E5%8C%85%E6%8D%A1%E5%88%B08%E5%80%8D%E9%95%9C%E5%BF%AB%E5%87%86%E7%8B%A0.html">【Python】Python元组拆包捡到8倍镜快准狠</a></li>
<li class="toctree-l2"><a class="reference internal" href="002012-%E3%80%90Python%E3%80%91%E8%83%BD%E5%8F%96%E5%80%BC%E4%BA%A6%E8%83%BD%E8%B5%8B%E5%80%BC%E7%9A%84Python%E5%88%87%E7%89%87.html">【Python】能取值亦能赋值的Python切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="002013-%E3%80%90Python%E3%80%91%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E5%BC%95%E5%8F%91%E7%9A%84Python%E5%88%97%E8%A1%A8%E9%99%B7%E8%BF%9B.html">【Python】序列赋值引发的Python列表陷进</a></li>
<li class="toctree-l2"><a class="reference internal" href="002014-%E3%80%90Python%E3%80%91%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8A%EF%BC%89.html">【Python】深度剖析Python字典和集合（上）</a></li>
<li class="toctree-l2"><a class="reference internal" href="002015-%E3%80%90Python%E3%80%91%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8B%EF%BC%89.html">【Python】深度剖析Python字典和集合（下）</a></li>
<li class="toctree-l2"><a class="reference internal" href="002016-%E3%80%90Python%E3%80%91%E5%8E%9F%E6%9D%A5Python%E5%87%BD%E6%95%B0%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1.html">【Python】原来Python函数只是个对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="002017-%E3%80%90Python%E3%80%91Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88.html">【Python】Python函数参数和注解是什么</a></li>
<li class="toctree-l2"><a class="reference internal" href="002018-%E3%80%90Python%E3%80%91Python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E5%A4%9A%E5%B0%91.html">【Python】Python设计模式知多少</a></li>
<li class="toctree-l2"><a class="reference internal" href="002019-%E3%80%90Python%E3%80%91Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">【Python】Python函数装饰器基础知识</a></li>
<li class="toctree-l2"><a class="reference internal" href="002020-%E3%80%90Python%E3%80%91%E5%85%B3%E4%BA%8EPython%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E5%88%87.html">【Python】关于Python闭包的一切</a></li>
<li class="toctree-l2"><a class="reference internal" href="002021-%E3%80%90Python%E3%80%91Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html">【Python】Python函数装饰器高级用法</a></li>
<li class="toctree-l2"><a class="reference internal" href="002022-%E3%80%90Python%E3%80%91Python%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E8%8A%82%E6%96%B0%E7%BC%96.html">【Python】Python字符与字节新编</a></li>
<li class="toctree-l2"><a class="reference internal" href="002023-%E3%80%90Python%E3%80%91Python%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86.html">【Python】Python编解码问题与文本文件处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="002024-%E3%80%90Python%E3%80%91Python%E5%8F%98%E9%87%8F%E5%B0%8F%E7%A7%98%E5%AF%86.html">【Python】Python变量小秘密</a></li>
<li class="toctree-l2"><a class="reference internal" href="002025-%E3%80%90Python%E3%80%91Python%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%88%E4%B8%8A%EF%BC%89.html">【Python】Python如何设计面向对象的类（上）</a></li>
<li class="toctree-l2"><a class="reference internal" href="002026-%E3%80%90Python%E3%80%91Python%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%EF%BC%88%E4%B8%8B%EF%BC%89.html">【Python】Python如何设计面向对象的类（下）</a></li>
<li class="toctree-l2"><a class="reference internal" href="002027-%E3%80%90Python%E3%80%91Python%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB.html">【Python】Python中的接口协议和抽象基类</a></li>
<li class="toctree-l2"><a class="reference internal" href="002028-%E3%80%90Python%E3%80%91Python%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8.html">【Python】Python抽象基类的定义与使用</a></li>
<li class="toctree-l2"><a class="reference internal" href="002029-%E3%80%90Python%E3%80%91Python%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94.html">【Python】Python可迭代的对象与迭代器的对比</a></li>
<li class="toctree-l2"><a class="reference internal" href="002030-%E3%80%90Python%E3%80%91%E9%95%BF%E7%AF%87%E5%A4%A7%E8%AE%BAPython%E7%94%9F%E6%88%90%E5%99%A8.html">【Python】长篇大论Python生成器</a></li>
<li class="toctree-l2"><a class="reference internal" href="002031-%E3%80%90Python%E3%80%91Python%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8.html">【Python】Python上下文管理器</a></li>
<li class="toctree-l2"><a class="reference internal" href="002032-%E3%80%90Python%E3%80%91Python%E5%8D%8F%E7%A8%8B%E7%9F%A5%E5%A4%9A%E5%B0%91.html">【Python】Python协程知多少</a></li>
<li class="toctree-l2"><a class="reference internal" href="002033-%E3%80%90Python%E3%80%91Python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6.html">【Python】Python并发编程从入门到进阶</a></li>
<li class="toctree-l2"><a class="reference internal" href="003001-%E3%80%90pytest%E3%80%91pytest%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html">【pytest】pytest快速入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="003002-%E3%80%90pytest%E3%80%91pytest132%E4%B8%AA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E7%94%A8%E6%B3%95.html">【pytest】pytest132个命令行参数用法</a></li>
<li class="toctree-l2"><a class="reference internal" href="003003-%E3%80%90pytest%E3%80%91pytest%E7%B2%BE%E9%80%9Afixture.html">【pytest】pytest精通fixture</a></li>
<li class="toctree-l2"><a class="reference internal" href="003004-%E3%80%90pytest%E3%80%91pytest%E5%86%85%E7%BD%AE%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89marker.html">【pytest】pytest内置和自定义marker</a></li>
<li class="toctree-l2"><a class="reference internal" href="003005-%E3%80%90pytest%E3%80%91pytest%E5%8F%82%E6%95%B0%E5%8C%96%E8%BF%9B%E9%98%B6.html">【pytest】pytest参数化进阶</a></li>
<li class="toctree-l2"><a class="reference internal" href="003006-%E3%80%90pytest%E3%80%91pytest%E6%96%AD%E8%A8%80%E6%8A%80%E5%B7%A7.html">【pytest】pytest断言技巧</a></li>
<li class="toctree-l2"><a class="reference internal" href="003007-%E3%80%90pytest%E3%80%91pytest%E7%94%A8%E4%BE%8B%E6%9F%A5%E6%89%BE%E5%8E%9F%E7%90%86.html">【pytest】pytest用例查找原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="004001-%E3%80%90Django%E3%80%91Django%E5%8C%86%E5%8C%86%E4%B8%80%E7%9C%BC%E5%8D%B4%E8%A7%A3%E7%AD%94%E4%BA%86%E5%A4%9A%E5%B9%B4%E7%96%91%E6%83%91.html">【Django】Django匆匆一眼却解答了多年疑惑</a></li>
<li class="toctree-l2"><a class="reference internal" href="004002-%E3%80%90Django%E3%80%91Django%E6%90%AD%E5%BB%BA%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E9%81%BF%E5%9D%91%E7%BB%86%E8%8A%82.html">【Django】Django搭建示例项目实战与避坑细节</a></li>
<li class="toctree-l2"><a class="reference internal" href="004003-%E3%80%90Django%E3%80%91Django%E5%AE%98%E6%96%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%A0%87%E5%87%86%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.html">【Django】Django官方为什么没有标准项目结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="004004-%E3%80%90Django%E3%80%91Django%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%B8%8D%E9%B8%A1%E8%82%8B%E5%8F%8D%E8%80%8C%E5%BE%88%E9%87%8D%E8%A6%81.html">【Django】Django认证系统并不鸡肋反而很重要</a></li>
<li class="toctree-l2"><a class="reference internal" href="004005-%E3%80%90Django%E3%80%91%E8%87%AA%E5%AE%9A%E4%B9%89Django%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88.html">【Django】自定义Django认证系统的技术方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="004006-%E3%80%90Django%E3%80%91%E5%BF%AB%E7%94%A8DjangoRESTframework%E5%86%99%E5%86%99API%E5%90%A7.html">【Django】快用DjangoRESTframework写写API吧</a></li>
<li class="toctree-l2"><a class="reference internal" href="004007-%E3%80%90Django%E3%80%91%E6%8F%AD%E5%BC%80DRF%E5%BA%8F%E5%88%97%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1.html">【Django】揭开DRF序列化技术的神秘面纱</a></li>
<li class="toctree-l2"><a class="reference internal" href="004008-%E3%80%90Django%E3%80%91DRF%E5%AF%B9Django%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%81%9A%E4%BA%86%E6%8A%80%E6%9C%AF%E5%8D%87%E7%BA%A7.html">【Django】DRF对Django请求响应做了技术升级</a></li>
<li class="toctree-l2"><a class="reference internal" href="004009-%E3%80%90Django%E3%80%91DRF%E7%B1%BB%E8%A7%86%E5%9B%BE%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81DRY%E8%B5%B7%E6%9D%A5.html">【Django】DRF类视图让你的代码DRY起来</a></li>
<li class="toctree-l2"><a class="reference internal" href="004010-%E3%80%90Django%E3%80%91DRF%E6%AF%94Django%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%9D%83%E9%99%90%E9%AB%98%E5%9C%A8%E5%93%AA%E9%87%8C.html">【Django】DRF比Django的认证和权限高在哪里</a></li>
<li class="toctree-l2"><a class="reference internal" href="004011-%E3%80%90Django%E3%80%91DRF%E4%BD%BF%E7%94%A8%E8%B6%85%E9%93%BE%E6%8E%A5API%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3RESTful.html">【Django】DRF使用超链接API实现真正RESTful</a></li>
<li class="toctree-l2"><a class="reference internal" href="004012-%E3%80%90Django%E3%80%91DRF%E7%BB%88%E6%9E%81%E5%B0%81%E8%A3%85ViewSet%E5%92%8CRouter%E9%99%84%E6%95%99%E7%A8%8BPDF%E6%BA%90%E7%A0%81.html">【Django】DRF终极封装ViewSet和Router附教程PDF源码</a></li>
<li class="toctree-l2"><a class="reference internal" href="005001-%E3%80%90Flask%E3%80%91Flask%E4%B8%80%E5%88%86%E9%92%9FMock%E4%B8%80%E4%B8%AAAPI.html">【Flask】Flask一分钟Mock一个API</a></li>
<li class="toctree-l2"><a class="reference internal" href="005002-%E3%80%90Flask%E3%80%91Python%E5%BE%AE%E5%9E%8BWeb%E6%A1%86%E6%9E%B6Flask%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html">【Flask】Python微型Web框架Flask快速入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="005003-%E3%80%90Flask%E3%80%91Flask%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E7%AB%9F%E7%84%B6%E6%98%AF%E8%BF%99%E6%A0%B7.html">【Flask】Flask官方推荐项目结构竟然是这样</a></li>
<li class="toctree-l2"><a class="reference internal" href="005004-%E3%80%90Flask%E3%80%91Flask%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E6%97%B6%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BA%9B%E5%95%A5.html">【Flask】Flask启动应用时都干了些啥</a></li>
<li class="toctree-l2"><a class="reference internal" href="005005-%E3%80%90Flask%E3%80%91Flask%E4%BD%BF%E7%94%A8SQLite%E6%95%B0%E6%8D%AE%E5%BA%93.html">【Flask】Flask使用SQLite数据库</a></li>
<li class="toctree-l2"><a class="reference internal" href="005006-%E3%80%90Flask%E3%80%91Flask%E7%9A%84Blueprints%E5%92%8CViews.html">【Flask】Flask的Blueprints和Views</a></li>
<li class="toctree-l2"><a class="reference internal" href="005007-%E3%80%90Flask%E3%80%91Flask%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.html">【Flask】Flask项目发布流程</a></li>
<li class="toctree-l2"><a class="reference internal" href="006001-%E3%80%90FastAPI%E3%80%91FastAPI%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%A4%AA%E6%A3%92%E4%BA%86%EF%BC%88%E4%B8%8A%EF%BC%89.html">【FastAPI】FastAPI官方教程太棒了（上）</a></li>
<li class="toctree-l2"><a class="reference internal" href="006002-%E3%80%90FastAPI%E3%80%91FastAPI%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%A4%AA%E6%A3%92%E4%BA%86%EF%BC%88%E4%B8%8B%EF%BC%89.html">【FastAPI】FastAPI官方教程太棒了（下）</a></li>
<li class="toctree-l2"><a class="reference internal" href="006003-%E3%80%90FastAPI%E3%80%91%E5%85%B3%E4%BA%8EFastAPI%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF%E5%92%8C%E7%BB%86%E8%8A%82.html">【FastAPI】关于FastAPI异步并发的技术背景和细节</a></li>
<li class="toctree-l2"><a class="reference internal" href="006004-%E3%80%90FastAPI%E3%80%91FastAPI%E4%BD%BF%E7%94%A8typing%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA.html">【FastAPI】FastAPI使用typing类型提示</a></li>
<li class="toctree-l2"><a class="reference internal" href="007001-%E3%80%90Locust%E3%80%91Python%E6%8A%80%E6%9C%AF%E6%A0%88%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Locust%E5%85%A5%E9%97%A8.html">【Locust】Python技术栈性能测试工具Locust入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="007002-%E3%80%90Locust%E3%80%91locustfile%E4%B8%AD%E7%9A%84User%E7%B1%BB%E5%92%8CHttpUser%E7%B1%BB.html">【Locust】locustfile中的User类和HttpUser类</a></li>
<li class="toctree-l2"><a class="reference internal" href="007003-%E3%80%90Locust%E3%80%91Locust%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%40task%E5%92%8C%40events.html">【Locust】Locust性能测试工具核心技术&#64;task和&#64;events</a></li>
<li class="toctree-l2"><a class="reference internal" href="008001-%E3%80%90HttpRunner%E3%80%91HttpRunner3%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90__init__%E6%96%87%E4%BB%B6%E5%B9%B2%E4%BA%86%E4%BA%9B%E5%95%A5.html">【HttpRunner】HttpRunner3源码剖析__init__文件干了些啥</a></li>
<li class="toctree-l2"><a class="reference internal" href="008002-%E3%80%90HttpRunner%E3%80%91HttpRunner3%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%8F%91%E5%87%BA%E5%8E%BB%E7%9A%84.html">【HttpRunner】HttpRunner3的HTTP请求是怎么发出去的</a></li>
<li class="toctree-l2"><a class="reference internal" href="008003-%E3%80%90HttpRunner%E3%80%91HttpRunner3%E7%9A%84%E7%94%A8%E4%BE%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84.html">【HttpRunner】HttpRunner3的用例是怎么运行起来的</a></li>
<li class="toctree-l2"><a class="reference internal" href="008004-%E3%80%90HttpRunner%E3%80%91HttpRunner3%E7%9A%84%E5%8F%98%E9%87%8F%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84.html">【HttpRunner】HttpRunner3的变量是如何传递的</a></li>
<li class="toctree-l2"><a class="reference internal" href="008005-%E3%80%90HttpRunner%E3%80%91HttpRunner3%E7%9A%84%24%E7%AC%A6%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E7%9A%84.html">【HttpRunner】HttpRunner3的$符号是如何解析的</a></li>
<li class="toctree-l2"><a class="reference internal" href="009001-%E3%80%90%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E3%80%91%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6mitmproxy%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7.html">【录制回放】从零开始学mitmproxy抓包工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="009002-%E3%80%90%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E3%80%91Postman%E7%AB%9F%E7%84%B6%E8%BF%98%E8%83%BD%E5%BD%95%E5%88%B6%E6%B5%81%E9%87%8F.html">【录制回放】Postman竟然还能录制流量</a></li>
<li class="toctree-l2"><a class="reference internal" href="009003-%E3%80%90%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E3%80%91%E5%9F%BA%E4%BA%8EHAR%E5%8C%85%E7%9A%84%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE.html">【录制回放】基于HAR包的流量录制回放</a></li>
<li class="toctree-l2"><a class="reference internal" href="010001-%E3%80%90%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%91%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95Pairwise%E5%B7%A5%E5%85%B7.html">【测试工具】功能测试用例自动生成算法Pairwise工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="010002-%E3%80%90%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%91%E4%B8%80%E6%AC%A1%E5%85%A8%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%80%9D%E8%80%83.html">【测试工具】一次全量数据对比工具发现问题的过程与思考</a></li>
<li class="toctree-l2"><a class="reference internal" href="011001-%E3%80%90%E7%AE%97%E6%B3%95%E3%80%9180%E9%81%93%E9%AB%98%E9%A2%91%E7%AE%97%E6%B3%95%E9%A2%98Python%E7%89%88.html">【算法】80道高频算法题Python版</a></li>
<li class="toctree-l2"><a class="reference internal" href="012001-%E3%80%90Golang%E3%80%91%E6%80%8E%E4%B9%88%E5%86%99Go%E4%BB%A3%E7%A0%81.html">【Golang】怎么写Go代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="012002-%E3%80%90Golang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E6%96%97%E5%9C%B0%E4%B8%BB.html">【Golang】多线程简单斗地主</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">【Golang】Dockerfile文件万字全面解析</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">格式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#escape">escape</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#escape-1">escape=`</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">环境替换</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dockerignore-file">.dockerignore file</a></li>
<li class="toctree-l3"><a class="reference internal" href="#from">FROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maintainer">MAINTAINER</a></li>
<li class="toctree-l3"><a class="reference internal" href="#env">ENV</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy">COPY</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#entrypoint-exec">ENTRYPOINT Exec示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#entrypoint-shell">ENTRYPOINT Shell示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmdentrypoint">CMD和ENTRYPOINT如何结合使用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#volume">VOLUME</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user">USER</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arg">ARG</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">范围</a></li>
<li class="toctree-l4"><a class="reference internal" href="#args">预定义ARGs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">对缓存的影响</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#onbuild">ONBUILD</a></li>
<li class="toctree-l3"><a class="reference internal" href="#healthcheck">HEALTHCHECK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executed-as-cmd-s-c-echo-default">Executed as cmd /S /C echo default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executed-as-cmd-s-c-powershell-command-write-host-default">Executed as cmd /S /C powershell -command Write-Host default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executed-as-powershell-command-write-host-hello">Executed as powershell -command Write-Host hello</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executed-as-cmd-s-c-echo-hello">Executed as cmd /S /C echo hello</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dockerfile">Dockerfile示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#youll-now-have-two-images-907ad6c2736f-with-bar-and-695d7793cbe4-with">You’ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</a></li>
<li class="toctree-l3"><a class="reference internal" href="#oink">/oink.</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="013001-%E3%80%90UI%E8%87%AA%E5%8A%A8%E5%8C%96%E3%80%91webdriver%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E8%BF%87%E7%9A%84chrome.html">【UI自动化】webdriver使用已打开过的chrome</a></li>
<li class="toctree-l2"><a class="reference internal" href="013002-%E3%80%90UI%E8%87%AA%E5%8A%A8%E5%8C%96%E3%80%91send_keys%E6%8A%A5%E9%94%99element_not_interactable.html">【UI自动化】send_keys报错element_not_interactable</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8E%86%E5%8F%B2%E6%9D%82%E6%96%87.html">历史杂文</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">读书笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97.html">更新日志</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E5%B0%8A%E4%BA%AB%E6%9C%8D%E5%8A%A1.html">尊享服务</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">测试开发体系</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../chapters/%E6%9B%B4%E5%A4%9A%E8%AF%AD%E8%A8%80.html">更多语言</a> &raquo;</li>
        
      <li>【Golang】Dockerfile文件万字全面解析</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/更多语言/012003-【Golang】Dockerfile文件万字全面解析.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="golangdockerfile">
<h1>【Golang】Dockerfile文件万字全面解析<a class="headerlink" href="#golangdockerfile" title="Permalink to this headline">¶</a></h1>
<p><img alt="image1" src="../_images/wanggang6.png" /></p>
<p><code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>是一个文本文件，包含一些Docker指令。执行<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code>，Docker就会执行<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>里面的指令，来自动创建镜像。</p>
<div class="section" id="id1">
<h2>用法<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p><img alt="image2" src="../_images/image-20200822110105335_副本.png" /></p>
<p>Dockerfile里面的指令可以访问context这些文件。</p>
<p>context是递归的，<code class="docutils literal notranslate"><span class="pre">PATH</span></code>包含所有子目录，<code class="docutils literal notranslate"><span class="pre">URL</span></code>包含所有子模块。</p>
<p>例子，把当前目录当做context，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build .

Sending build context to Docker daemon  <span class="m">6</span>.51 MB
...
</pre></div>
</div>
<p>build是由Docker daemon(守护进程)来运行，而不是CLI。</p>
<p>build会把整个context发给daemon。所以最好把context设置为空目录，把Dockerfile放进去。只添加需要的文件，为了提高build性能，还可以添加<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>来排除一些文件和目录。</p>
<p>Warning！不要用系统根目录<code class="docutils literal notranslate"><span class="pre">/</span></code>作为PATH，不然会把根目录下所有东西都传给Docker
daemon。</p>
<p>一般会把Dockerfile放在context根目录下，也可以使用<code class="docutils literal notranslate"><span class="pre">-f</span></code>来指定其他路径，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -f /path/to/a/Dockerfile .
</pre></div>
</div>
<p>指定镜像存放仓库可以使用<code class="docutils literal notranslate"><span class="pre">-t</span></code>，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t shykes/myapp .
</pre></div>
</div>
<p>支持多个，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .
</pre></div>
</div>
<p>Docker daemon在执行Dockfile的指令前，会做检查，如果有语法错误会报错，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t test/myapp .

Sending build context to Docker daemon <span class="m">2</span>.048 kB
Error response from daemon: Unknown instruction: RUNCMD
</pre></div>
</div>
<p>Docker
daemon执行指令，是一个一个执行，一个一个提交的。执行结束会生成镜像ID。自动清理context。</p>
<p><code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">cd</span> <span class="pre">/tmp</span></code>是无效的，因为daemon是独立执行每条指令的，不会作用到后面的指令。</p>
<p>为了加速build过程，Docker会重复使用中间镜像(缓存)，在console日志中可以看到<code class="docutils literal notranslate"><span class="pre">Using</span> <span class="pre">cache</span></code>，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build -t svendowideit/ambassador .

Sending build context to Docker daemon <span class="m">15</span>.36 kB
Step <span class="m">1</span>/4 : FROM alpine:3.2
 ---&gt; 31f630c65071
Step <span class="m">2</span>/4 : MAINTAINER SvenDowideit@home.org.au
 ---&gt; Using cache
 ---&gt; 2a1c91448f5f
Step <span class="m">3</span>/4 : RUN apk update <span class="o">&amp;&amp;</span>      apk add socat <span class="o">&amp;&amp;</span>        rm -r /var/cache/
 ---&gt; Using cache
 ---&gt; 21ed6e7fbb73
Step <span class="m">4</span>/4 : CMD env <span class="p">|</span> grep <span class="nv">_TCP</span><span class="o">=</span> <span class="p">|</span> <span class="o">(</span>sed <span class="s1">&#39;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&#39;</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="nb">wait</span><span class="o">)</span> <span class="p">|</span> sh
 ---&gt; Using cache
 ---&gt; 7ea8aef582cc
Successfully built 7ea8aef582cc
</pre></div>
</div>
<p>cache来源于之前本地build过的镜像，或者使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">load</span></code>加载的镜像。</p>
<p>如果想直接指定一个镜像作为cache，可以使用<code class="docutils literal notranslate"><span class="pre">--cache-from</span></code>。</p>
</div>
<div class="section" id="id2">
<h2>格式<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>’’’ ## Comment INSTRUCTION arguments</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`#`开头是注释或者parser directive（提示解析器做特殊处理）。

指令是忽略大小写的，不过为了和参数区分，一般全大写。

Dockerfile从上往下顺序执行指令，第一条指令必须是`FROM`，定义build的parent image（父镜像）。没有parent的镜像叫base image。

![](012003-【Golang】Dockerfile文件万字全面解析/2-3_副本.png)

参数里面的`#`就不是注释了，是参数的一部分，

&#39;&#39;&#39;
## Comment
RUN echo &#39;we are running some # of cool things&#39;
</pre></div>
</div>
<p>注释在Dockerfile指令执行前，会被移除。以下是等价的，</p>
<div class="line-block">
<div class="line">’’’ RUN echo hello</div>
<div class="line">## comment world</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">RUN echo hello </span><span class="se">\</span>
<span class="s1">world</span>
</pre></div>
</div>
<p>注意，注释不支持换行符<code class="docutils literal notranslate"><span class="pre">\</span></code>。</p>
<p>注释和指令前面的空格会被忽略，以下是等价的，</p>
<p>’’’ # this is a comment-line RUN echo hello RUN echo world</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">## this is a comment-line</span>
<span class="s1">RUN echo hello</span>
<span class="s1">RUN echo world</span>
</pre></div>
</div>
<p>但是参数里面的空格，是会被保留的，</p>
<p>’’’ RUN echo “
hello
world”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## Parser directives</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">## directive=value</span>
</pre></div>
</div>
<p>Parser directives是一种特殊的注释，用来提示解析器做特殊处理。</p>
<p>但是Parser directives并不会添加layers到build中，也不会被识别为build
step。</p>
<p>如果注释、空行、或者指令被运行后，Docker就不会再识别Parser
directives了，所以必须把Parser
directives放在Dockerfile的最前面的最前面。</p>
<p>Parser
directives是忽略大小写的，不过一般约定为全小写。同时约定随后跟一个空行。</p>
<p>Parser directives不支持换行符。</p>
<p>以下是一些无效示例，</p>
<p>无效–换行符</p>
<div class="line-block">
<div class="line">’’’ ## direc</div>
<div class="line">tive=value</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">无效</span><span class="o">--</span><span class="n">出现了2次</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">## directive=value1</span>
<span class="s1">## directive=value2</span>

<span class="s1">FROM ImageName</span>
</pre></div>
</div>
<p>无效–在指令之后就是普通的注释</p>
<p>’’’ FROM ImageName ## directive=value</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">无效</span><span class="o">--</span><span class="n">在普通注释之后也变成了普通注释</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">## About my dockerfile</span>
<span class="s1">## directive=value</span>
<span class="s1">FROM ImageName</span>
</pre></div>
</div>
<p>无效–未知命令会被视为普通注释，普通注释之后也是普通注释</p>
<p>’’’ ## unknowndirective=value ## knowndirective=value</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Parser directives同一行的空格会被忽略，以下是等价的，

&#39;&#39;&#39;
#directive=value
## directive =value
#   directive= value
## directive = value
#     dIrEcTiVe=value
</pre></div>
</div>
<p>目前支持2个Parser directives，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">syntax</span></code>，依赖BuildKit</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">escape</span></code></p></li>
</ul>
<div class="section" id="escape">
<h3>escape<a class="headerlink" href="#escape" title="Permalink to this headline">¶</a></h3>
<p>反斜杠（默认）</p>
<div class="line-block">
<div class="line">’’’ ## escape=</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">或者反引号</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="escape-1">
<span id="id3"></span><h2>escape=`<a class="headerlink" href="#escape-1" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>用来指定转义符。这个在Windows系统很有用，因为`\`在Windows是路径分隔符。

比如，
</pre></div>
</div>
<div class="line-block">
<div class="line">FROM microsoft/nanoserver COPY testfile.txt c:\ RUN dir c:</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>会执行失败，

```sh
PS C:\John&gt; docker build -t cmd .
Sending build context to Docker daemon 3.072 kB
Step 1/2 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step 2/2 : COPY testfile.txt c:\RUN dir c:
GetFileAttributesEx c:RUN: The system cannot find the file specified.
PS C:\John&gt;
</pre></div>
</div>
<p>使用escape可以替换<code class="docutils literal notranslate"><span class="pre">\</span></code>为`</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## escape=`</span>

<span class="n">FROM</span> <span class="n">microsoft</span><span class="o">/</span><span class="n">nanoserver</span>
<span class="n">COPY</span> <span class="n">testfile</span><span class="o">.</span><span class="n">txt</span> <span class="n">c</span><span class="p">:</span>\
<span class="n">RUN</span> <span class="nb">dir</span> <span class="n">c</span><span class="p">:</span>\
</pre></div>
</div>
<p>执行成功，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>PS C:<span class="se">\J</span>ohn&gt; docker build -t succeeds --no-cache<span class="o">=</span><span class="nb">true</span> .
Sending build context to Docker daemon <span class="m">3</span>.072 kB
Step <span class="m">1</span>/3 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step <span class="m">2</span>/3 : COPY testfile.txt c:<span class="se">\</span>
 ---&gt; 96655de338de
Removing intermediate container 4db9acbb1682
Step <span class="m">3</span>/3 : RUN dir c:<span class="se">\</span>
 ---&gt; Running in a2c157f842f5
 Volume in drive C has no label.
 Volume Serial Number is 7E6D-E0F7

 Directory of c:<span class="se">\</span>

<span class="m">10</span>/05/2016  <span class="m">05</span>:04 PM             <span class="m">1</span>,894 License.txt
<span class="m">10</span>/05/2016  <span class="m">02</span>:22 PM    &lt;DIR&gt;          Program Files
<span class="m">10</span>/05/2016  <span class="m">02</span>:14 PM    &lt;DIR&gt;          Program Files <span class="o">(</span>x86<span class="o">)</span>
<span class="m">10</span>/28/2016  <span class="m">11</span>:18 AM                <span class="m">62</span> testfile.txt
<span class="m">10</span>/28/2016  <span class="m">11</span>:20 AM    &lt;DIR&gt;          Users
<span class="m">10</span>/28/2016  <span class="m">11</span>:20 AM    &lt;DIR&gt;          Windows
           <span class="m">2</span> File<span class="o">(</span>s<span class="o">)</span>          <span class="m">1</span>,956 bytes
           <span class="m">4</span> Dir<span class="o">(</span>s<span class="o">)</span>  <span class="m">21</span>,259,096,064 bytes free
 ---&gt; 01c7f3bef04f
Removing intermediate container a2c157f842f5
Successfully built 01c7f3bef04f
PS C:<span class="se">\J</span>ohn&gt;
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>环境替换<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>环境变量（使用<code class="docutils literal notranslate"><span class="pre">ENV</span></code>指令来定义环境变量）能够用在指令中作为变量，被<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>解释。还可以处理转义符，以便在语句中照字面值地包含variable-like语法。</p>
<p>使用<code class="docutils literal notranslate"><span class="pre">$variable_name</span></code>或<code class="docutils literal notranslate"><span class="pre">${variable_name}</span></code>来引用环境变量。</p>
<p>可以使用双括弧和下划线来命名，如<code class="docutils literal notranslate"><span class="pre">${foo}_bar</span></code>。同时支持<code class="docutils literal notranslate"><span class="pre">bash</span></code>修饰符，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">${variable:-word}</span></code> set <code class="docutils literal notranslate"><span class="pre">variable</span></code>后就是set的值，没有set
<code class="docutils literal notranslate"><span class="pre">variable</span></code>值就是<code class="docutils literal notranslate"><span class="pre">word</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">${variable:+word}</span></code> set <code class="docutils literal notranslate"><span class="pre">variable</span></code>后值就是<code class="docutils literal notranslate"><span class="pre">word</span></code>，没有set
<code class="docutils literal notranslate"><span class="pre">variable</span></code>就是空字符串</p></li>
</ul>
<p>word既可以是string，也可以是另外一个环境变量。</p>
<p>可以在变量前加转义符，比如<code class="docutils literal notranslate"><span class="pre">\$foo</span></code>
，<code class="docutils literal notranslate"><span class="pre">\${foo}</span></code>会被分别转义为<code class="docutils literal notranslate"><span class="pre">$foo</span></code> 和<code class="docutils literal notranslate"><span class="pre">${foo}</span></code>。</p>
<p>示例，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>FROM busybox
ENV foo /bar
WORKDIR ${foo}   # WORKDIR /bar
ADD . $foo       # ADD . /bar
COPY \$foo /quux # COPY $foo /quux
</pre></div>
</div>
<p>Dockerfile的一下指令都支持环境变量</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADD</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FROM</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LABEL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">STOPSIGNAL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code> (结合以上指令使用)</p></li>
</ul>
<p>需要注意的是，变量替换是针对整条指令的，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ENV abc=hello
ENV abc=bye def=$abc
ENV ghi=$abc
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">def</span></code>的值是hello，而不是bye，因为上一条指令赋值的hello。</p>
<p><code class="docutils literal notranslate"><span class="pre">ghi</span></code>的值才会是bye。</p>
</div>
<div class="section" id="dockerignore-file">
<h2>.dockerignore file<a class="headerlink" href="#dockerignore-file" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>文件位于context根目录，会把匹配到的文件和目录排除在context之外。</p>
<p>这样就可以在使用<code class="docutils literal notranslate"><span class="pre">ADD</span></code>和<code class="docutils literal notranslate"><span class="pre">COPY</span></code>命令时，避免把一些大文件或者敏感信息文件和目录，发送到Docker
daemon。</p>
<p>context是由<code class="docutils literal notranslate"><span class="pre">PATH</span></code>和<code class="docutils literal notranslate"><span class="pre">URL</span></code>定义的，所以<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>文件会匹配这2个路径。</p>
<p><code class="docutils literal notranslate"><span class="pre">/foo/bar</span></code> == <code class="docutils literal notranslate"><span class="pre">foo/bar</span></code></p>
<p>示例，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>## comment
*/temp*
*/*/temp*
temp?
</pre></div>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Rule</p></th>
<th class="head"><p>Behavior</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">c</span>
<span class="pre">omment</span></code></p></td>
<td><p>注释忽略</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span>
<span class="pre">/temp*</span></code></p></td>
<td><p>排除root的子目录下，<code class="docutils literal notranslate"><span class="pre">temp</span></code>开头的文件和目录。
如<code class="docutils literal notranslate"><span class="pre">/somedir/temporary.txt</span></code> 和 <code class="docutils literal notranslate"><span class="pre">/somedir/temp</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">*/*</span>
<span class="pre">/temp*</span></code></p></td>
<td><p>排除r
oot的<strong>二层</strong>目录下，<code class="docutils literal notranslate"><span class="pre">temp</span></code>开头的文件和目录。如
<code class="docutils literal notranslate"><span class="pre">/somedir/subdir/temporary.txt</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>`
<cite>temp?`</cite></p></td>
<td><p>排除root下， <code class="docutils literal notranslate"><span class="pre">temp</span></code>+1个字符的文件和目录。如
<code class="docutils literal notranslate"><span class="pre">/tempa</span></code> 和<code class="docutils literal notranslate"><span class="pre">/tempb</span></code></p></td>
</tr>
</tbody>
</table>
<p>匹配遵循Go语言的<a class="reference external" href="http://golang.org/pkg/path/filepath#Match">filepath.Match</a>规则。</p>
<p>Docker还支持<code class="docutils literal notranslate"><span class="pre">**</span></code>，匹配任意数量的目录（包括0）。如<code class="docutils literal notranslate"><span class="pre">**/*.go</span></code>排除<code class="docutils literal notranslate"><span class="pre">.go</span></code>结尾的，包括context
root下所有目录。</p>
<p>如果排除了一堆文件后，想只包含其中几个文件，可以使用异常规则<code class="docutils literal notranslate"><span class="pre">!</span></code>。</p>
<p>示例，排除<code class="docutils literal notranslate"><span class="pre">.md</span></code>结尾的文件，包含<code class="docutils literal notranslate"><span class="pre">README.md</span></code>，</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>*.md
!README.md
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">README-secret.md</span></code>不会被排除，因为<code class="docutils literal notranslate"><span class="pre">!README*.md</span></code>能匹配到<code class="docutils literal notranslate"><span class="pre">README-secret.md</span></code>，又把<code class="docutils literal notranslate"><span class="pre">README-secret.md</span></code>包含进来了。</p>
<p><code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>文件甚至可以排除<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>
和<code class="docutils literal notranslate"><span class="pre">.dockerignore</span></code>，然而并没有什么卵用，这些文件还是会被发送到Docker
daemon，只是<code class="docutils literal notranslate"><span class="pre">ADD</span></code>和<code class="docutils literal notranslate"><span class="pre">COPY</span></code>命令不会把它们复制到镜像了。</p>
</div>
<div class="section" id="from">
<h2>FROM<a class="headerlink" href="#from" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">FROM</span></code>指令初始化一个新的buid stage，为后面的指令设置Parent Image。</p>
<p>’’’ FROM [–platform=] [AS ]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">或</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span>
</pre></div>
</div>
<p>或</p>
<p>’’’ FROM [–platform=] [&#64;] [AS ]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`--platform`，用来定义image的平台，如`linux/amd64`, `linux/arm64`, 或者`windows/amd64`，这样就能支持多平台镜像。

`tag` `digest`是可选的，都不填时，默认用最新的tag。如果找不到tag，builder就会报错。

`AS name`可以给image取个别名，在后续`FROM`和`COPY --from=&lt;name|index&gt;`指令中可以使用这个别名。

可以在一个Dockerfile文件中使用多个`FROM`。每个`FROM`都会把上个指令创建的状态清除。所以在每个新的`FROM`指令之前，记录commit输出的最后一个image ID。

`ARG`是唯一能在`FROM`之前的指令。

比如`--platform`，默认情况下，会使用build请求的默认平台。也可以使用全局build参数，通过`automatic platform ARGs`（依赖BuildKit）来强制把stage指定为本地build平台（`--platform=$BUILDPLATFORM`），然后用它来在stage中cross-compile目标平台。

`FROM`和`ARG`怎么结合使用呢？

`FROM`指令支持出现在第一个`FROM`之前的`ARG`声明的变量。

&#39;&#39;&#39;
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">FROM</span></code>之前声明的<code class="docutils literal notranslate"><span class="pre">ARG</span></code>是在build
stage之外的，所以它不能用在<code class="docutils literal notranslate"><span class="pre">FROM</span></code>后的任何指令中。如果要用，可以使用在build
stage中的不带value的<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令，</p>
<p>’’’ ARG VERSION=latest FROM busybox:$VERSION ARG VERSION RUN echo
$VERSION &gt; image_version</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>## RUN

- `RUN &lt;command&gt;` (*shell* 格式，Linux `/bin/sh -c`  Windows`cmd /S /C`)
- `RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]` (*exec* 格式)

`RUN`指令会在当前镜像之上的新layer中执行命令，commit结果，commit后的镜像会在`Dockerfile`的下一个step中使用。

`RUN`指令的commits符合Docker理念，commit is cheap，containers可以从image历史中任何记录创建，就像source control。

可以使用不同的`SHELL`，

**shell格式**

&#39;&#39;&#39;
RUN /bin/bash -c &#39;source $HOME/.bashrc; echo $HOME&#39;
</pre></div>
</div>
<p><strong>exec格式</strong></p>
<p>’’’ RUN [“/bin/bash”, “-c”, “echo hello”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>shell格式会调用command shell，而exec格式不会，所以exec中`$HOME`是没用的，要用的话直接执行shell `RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]`。

注意，exec格式被解析为JSON数组，所以只能用双引号。还需注意反斜杠，

错误

&#39;&#39;&#39;
RUN [&quot;c:\windows\system32\tasklist.exe&quot;]
</pre></div>
</div>
<p>正确</p>
<p>’’’ RUN [“c:windowssystem32tasklist.exe”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>默认是会启动`RUN`的缓存的，比如`RUN apt-get dist-upgrade -y`会在下次build的时候复用。可以使用`docker build --no-cache`来禁用缓存。

使用`ADD`和`COPY`指令也可以禁用`RUN`缓存。

## CMD

`CMD`和`RUN`是不同的。`RUN`指令是在build过程中执行command和commit结果。`CMD`在build时不会执行任何command，而是为image定义command，在container（镜像创建的容器）启动的时候执行。

- `CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]` (*exec* 格式，首选)
- `CMD [&quot;param1&quot;,&quot;param2&quot;]` (*ENTRYPOINT*默认参数)
- `CMD command param1 param2` (*shell* 格式)

一个`Dockerfile`只能有一个`CMD`指令，如果有多个，只有最后一个生效。

shell格式会调用command shell，而exec格式不会，所以exec中`$HOME`是没用的，要用的话直接执行shell `RUN [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]`。

注意，exec格式被解析为JSON数组，所以只能用双引号。还需注意反斜杠。

如果想要container每次运行相同的可执行文件，需要结合 `ENTRYPOINT`使用。

如果`docker run`定义了参数，那么会覆盖`CMD`定义。

## LABEL

&#39;&#39;&#39;
LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LABEL</span></code>用来给image添加metadata，是key-value键值对的形式。</p>
<p>示例，</p>
<p>’’’ LABEL “com.example.vendor”=“ACME Incorporated” LABEL
com.example.label-with-value=“foo” LABEL version=“1.0” LABEL
description=“This text illustrates
that label-values can span multiple lines.”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>一个image可以有多个label，一个label可以有多个键值对，以下是等价的，

&#39;&#39;&#39;
LABEL multi.label1=&quot;value1&quot; multi.label2=&quot;value2&quot; other=&quot;value3&quot;
</pre></div>
</div>
<div class="line-block">
<div class="line">’’’ LABEL multi.label1=“value1”</div>
<div class="line">multi.label2=“value2”</div>
<div class="line">other=“value3”</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>label会随着image继承，从base image或parent image继承到当前image。

重复的label，会用最新的覆盖旧的。

可以使用命令查看image的labels，

```shell
docker image inspect --format=&#39;&#39; myimage
</pre></div>
</div>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;com.example.vendor&quot;</span><span class="p">:</span> <span class="s2">&quot;ACME Incorporated&quot;</span><span class="p">,</span>
  <span class="nt">&quot;com.example.label-with-value&quot;</span><span class="p">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span>
  <span class="nt">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span>
  <span class="nt">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;This text illustrates that label-values can span multiple lines.&quot;</span><span class="p">,</span>
  <span class="nt">&quot;multi.label1&quot;</span><span class="p">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
  <span class="nt">&quot;multi.label2&quot;</span><span class="p">:</span> <span class="s2">&quot;value2&quot;</span><span class="p">,</span>
  <span class="nt">&quot;other&quot;</span><span class="p">:</span> <span class="s2">&quot;value3&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="maintainer">
<h2>MAINTAINER<a class="headerlink" href="#maintainer" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">MAINTAINER</span></code>已经弃用了，直接使用<code class="docutils literal notranslate"><span class="pre">LABLE</span></code>，</p>
<p>’’’ LABEL maintainer=“<a class="reference external" href="mailto:SvenDowideit&#37;&#52;&#48;home&#46;org&#46;au">SvenDowideit<span>&#64;</span>home<span>&#46;</span>org<span>&#46;</span>au</a>”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## EXPOSE</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code>定义了container监听的网络端口，支持TCP和UDP，默认TCP。</p>
<p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code>并不真正的发布端口，而只是一种预定义。</p>
<p>真正发布是在<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>的时候，使用<code class="docutils literal notranslate"><span class="pre">-p</span></code>或<code class="docutils literal notranslate"><span class="pre">-P</span></code>来发布。</p>
<p><code class="docutils literal notranslate"><span class="pre">-p</span></code>发布一个或多个端口，<code class="docutils literal notranslate"><span class="pre">-P</span></code>发布全部，并映射到高位端口。</p>
<p>示例，默认TCP，可以定义UDP，</p>
<p>’’’ EXPOSE 80/udp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>也可以同时定义TCP和UDP，

&#39;&#39;&#39;
EXPOSE 80/tcp
EXPOSE 80/udp
</pre></div>
</div>
<p>如果这里<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>使用了<code class="docutils literal notranslate"><span class="pre">-P</span></code>，将会暴露一次TCP端口和一次UDP端口，由于会映射到高位端口，它们的端口会不一样。</p>
<p>使用<code class="docutils literal notranslate"><span class="pre">-p</span></code>指定端口，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>docker run -p <span class="m">80</span>:80/tcp -p <span class="m">80</span>:80/udp ...
</pre></div>
</div>
<p>也可以使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">network</span></code>来创建网络在container之间通信而不需要暴露任何端口。因为container可以使用任何端口通信。</p>
</div>
<div class="section" id="env">
<h2>ENV<a class="headerlink" href="#env" title="Permalink to this headline">¶</a></h2>
<p>’’’ ENV ENV = …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`ENV`用来设置环境变量。有2种形式，以下是等价的，

&#39;&#39;&#39;
ENV myName=&quot;John Doe&quot; myDog=Rex\ The\ Dog \
    myCat=fluffy
</pre></div>
</div>
<p>’’’ ENV myName John Doe ENV myDog Rex The Dog ENV myCat fluffy</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>可以使用`docker inspect`来查看环境变量。也可以使用`docker run --env &lt;key&gt;=&lt;value&gt;`来修改环境变量。

`ENV`的作用域除了build，还包括container running。有时候会有副作用，比如`ENV DEBIAN_FRONTEND noninteractive`，所有操作都是非交互式的，无需向用户请求输入，直接运行命令。可能会使apt-get用户误认为是一个Debian-based image。正确的做法是为command添加单独的环境变量，如`RUN apt-get install -y python3`。

## ADD

&#39;&#39;&#39;
ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ADD</span></code>有2种形式，第2种是为了支持路径包含空格，所以加了双引号。</p>
<p><code class="docutils literal notranslate"><span class="pre">--chown</span></code>只适用于Linux container，对Windows无效。</p>
<p><code class="docutils literal notranslate"><span class="pre">ADD</span></code>的作用是从<code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>复制新文件，目录或者远程文件URLs，然后添加到<code class="docutils literal notranslate"><span class="pre">&lt;desc&gt;</span></code>所在的image文件系统。</p>
<p><code class="docutils literal notranslate"><span class="pre">src</span></code>如果是文件和目录，那么就是相对路径，相对于build的context。同时支持通配符，遵循Golang的filepath.Match规则。</p>
<p>示例，添加所有以“hom”开头的文件，</p>
<p>’’’ ADD hom* /mydir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>用`?`匹配单个字符，

&#39;&#39;&#39;
ADD hom?.txt /mydir/
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>是绝对路径，或者<code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>的相对路径。</p>
<p>示例，绝对路径，</p>
<p>’’’ ADD test.txt /absoluteDir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>相对路径，`&lt;WORKDIR&gt;/relativeDir/`，

&#39;&#39;&#39;
ADD test.txt relativeDir/
</pre></div>
</div>
<p>如果路径种包含特殊字符（如<code class="docutils literal notranslate"><span class="pre">[</span></code>和<code class="docutils literal notranslate"><span class="pre">]</span></code>），那么需要进行转义，</p>
<p>示例，添加一个文件<code class="docutils literal notranslate"><span class="pre">arr[0].txt</span></code>，</p>
<p>’’’ ADD arr[[]0].txt /mydir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>针对Linux，可以使用`--chown`定义username、groupname或者UID/GID，默认新文件和目录会被设置为UID为0，GID为0。

如果只设置username不设置groupname，或只设置UID不设置GID，GID会使用和UID相同的数值。

username和groupname会被container&#39;s root filesystem `/etc/passwd` and `/etc/group` 转换为UID/GID。如果container没有这2个文件，在设置了username/groupname后，就会报错。可以通过设置UID/GID来避免。

示例，

&#39;&#39;&#39;
ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
</pre></div>
</div>
<p>如果build使用STDIN (<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-</span> <span class="pre">&lt;</span> <span class="pre">somefile</span></code>)，就没有build
context，就只能用<code class="docutils literal notranslate"><span class="pre">ADD</span></code>URL。也可以在使用STDIN时添加压缩包
(<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-</span> <span class="pre">&lt;</span> <span class="pre">archive.tar.gz</span></code>)，压缩包根目录的<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>和其他压缩包会当做build
context。</p>
<p>如果<code class="docutils literal notranslate"><span class="pre">src</span></code>是一个远程文件URL，就会需要600权限(Linux)。如果远程文件有HTTP
<code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code>
header，header的timestamp会用来设置到dest文件的<code class="docutils literal notranslate"><span class="pre">mtime</span></code>。但是<code class="docutils literal notranslate"><span class="pre">mtime</span></code>不会反映文件是否修改和缓存是否应该更新。</p>
<p>如果URL文件需要授权，<code class="docutils literal notranslate"><span class="pre">ADD</span></code>是不支持的，需要使用<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">wget</span></code>,
<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">curl</span></code>，或者container里面的其他工具。</p>
<p><code class="docutils literal notranslate"><span class="pre">ADD</span></code>遵循以下规则：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code> 必须在build的<em>context</em> 中；不能
<code class="docutils literal notranslate"><span class="pre">ADD</span> <span class="pre">../something</span> <span class="pre">/something</span></code>添加context父目录的东西。因为
<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code>的第一步是把context，目录及其子目录发送到docker
daemon。</p></li>
<li><p>如果<code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code> 是URL，<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>
没有以斜杠结尾，那么文件从直接从URL下载后，然后直接复制到
<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code> 是URL，<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>
是以斜杠结尾的，那么会从URL解析出文件名，下载到<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;/&lt;filename&gt;</span></code>。比如，
<code class="docutils literal notranslate"><span class="pre">ADD</span> <span class="pre">http://example.com/foobar</span> <span class="pre">dest/</span></code> 会创建文件
<code class="docutils literal notranslate"><span class="pre">dest/foobar</span></code>。URL必须是明确的路径，以保证能找到合适的文件名(<code class="docutils literal notranslate"><span class="pre">http://example.com</span></code>
是无效的)。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>
是目录，那么整个目录都会被复制，包括文件系统的metadata。（目录本身不复制，只是内容）</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>是本地压缩包（如gzip, bzip2 or
xz），那么会被解压成目录。远程URL是<strong>不会</strong>解压的。解压相当于执行了
<code class="docutils literal notranslate"><span class="pre">tar</span> <span class="pre">-x</span></code>，如果dest路径下有文件冲突，会被重命名为“2”。（压缩包不是根据文件名判断的，而是根据内容，比如一个空文件命名为<code class="docutils literal notranslate"><span class="pre">.tar.gz</span></code>，是不会被解压复制的）</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code> 是任何其他文件，就会随同它的metadata一起复制。此时
<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code> 以斜杠
<code class="docutils literal notranslate"><span class="pre">/</span></code>结尾的话，就会被认为是一个目录，<code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>的内容会被写到<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;/base(&lt;src&gt;)</span></code>。</p></li>
<li><p>如果<code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>定义的是多个资源，不论是直接还是通配符匹配到的，
<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code> 必须是一个目录，且以斜杠<code class="docutils literal notranslate"><span class="pre">/</span></code>结尾。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>
不以斜杠结尾，那么就会被认为是一个普通文件，那么<code class="docutils literal notranslate"><span class="pre">&lt;src&gt;</span></code>
会被写到<code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code>。</p></li>
<li><p>如果 <code class="docutils literal notranslate"><span class="pre">&lt;dest&gt;</span></code> 不存在，那么path中的所有未创建的目录都会自动创建。</p></li>
</ul>
<p>如果<code class="docutils literal notranslate"><span class="pre">src</span></code>内容改变了，在第一次遇到<code class="docutils literal notranslate"><span class="pre">ADD</span></code>指令后，会禁用后续所有指令的缓存，包括<code class="docutils literal notranslate"><span class="pre">RUN</span></code>指令的缓存。</p>
</div>
<div class="section" id="copy">
<h2>COPY<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">COPY</span></code>和<code class="docutils literal notranslate"><span class="pre">ADD</span></code>的<strong>区别</strong>在于<code class="docutils literal notranslate"><span class="pre">ADD</span></code>可以添加远程URLS，<code class="docutils literal notranslate"><span class="pre">COPY</span></code>不能。</p>
<p>’’’ COPY [–chown=:] … COPY [–chown=:] [“”,… “”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`COPY`有2种形式，第2种是为了支持路径包含空格，所以加了双引号。

`--chown`只适用于Linux container，对Windows无效。

`COPY`的作用是从`&lt;src&gt;`复制新文件，目录，然后添加到`&lt;desc&gt;`所在的image文件系统。

`src`如果是文件和目录，那么就是相对路径，相对于build的context。同时支持通配符，遵循Golang的filepath.Match规则。

示例，添加所有以&quot;hom&quot;开头的文件，

&#39;&#39;&#39;
COPY hom* /mydir/
</pre></div>
</div>
<p>用<code class="docutils literal notranslate"><span class="pre">?</span></code>匹配单个字符，</p>
<p>’’’ COPY hom?.txt /mydir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`&lt;dest&gt;`是绝对路径，或者`WORKDIR`的相对路径。

示例，绝对路径，

&#39;&#39;&#39;
COPY test.txt /absoluteDir/
</pre></div>
</div>
<p>相对路径，<code class="docutils literal notranslate"><span class="pre">&lt;WORKDIR&gt;/relativeDir/</span></code>，</p>
<p>’’’ COPY test.txt relativeDir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果路径种包含特殊字符（如`[`和`]`），那么需要进行转义，

示例，添加一个文件`arr[0].txt`，

&#39;&#39;&#39;
COPY arr[[]0].txt /mydir/
</pre></div>
</div>
<p>针对Linux，可以使用<code class="docutils literal notranslate"><span class="pre">--chown</span></code>定义username、groupname或者UID/GID，默认新文件和目录会被设置为UID为0，GID为0。</p>
<p>如果只设置username不设置groupname，或只设置UID不设置GID，GID会使用和UID相同的数值。</p>
<p>username和groupname会被container’s root filesystem <code class="docutils literal notranslate"><span class="pre">/etc/passwd</span></code> and
<code class="docutils literal notranslate"><span class="pre">/etc/group</span></code>
转换为UID/GID。如果container没有这2个文件，在设置了username/groupname后，就会报错。可以通过设置UID/GID来避免。</p>
<p>示例，</p>
<p>’’’ COPY –chown=55:mygroup files* /somedir/ COPY –chown=bin files*
/somedir/ COPY –chown=1 files* /somedir/ COPY –chown=10:11 files*
/somedir/</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果build使用STDIN (`docker build - &lt; somefile`)，就没有build context，就不能用`COPY`。

`COPY`支持`--from=&lt;name|index&gt;`，用来指定src为之前buid的image（通过`FROM .. AS &lt;name&gt;`创建的）来替换build context。既可以是name也可以是index数字（所有使用`FROM`指令建立的build stages）。如果通过name找不到build stage，就会去找同名的image。

`COPY`遵循以下规则：

-  `&lt;src&gt;` 必须在build的*context* 中；不能 `COPY ../something /something`添加context父目录的东西。因为 `docker build `的第一步是把context，目录及其子目录发送到docker daemon。
-  如果 `&lt;src&gt;` 是目录，那么整个目录都会被复制，包括文件系统的metadata。（目录本身不复制，只是内容）
-  如果 `&lt;src&gt;` 是任何其他文件，就会随同它的metadata一起复制。此时 `&lt;dest&gt;` 以斜杠 `/`结尾的话，就会被认为是一个目录，`&lt;src&gt;`的内容会被写到`&lt;dest&gt;/base(&lt;src&gt;)`。
-  如果`&lt;src&gt;`定义的是多个资源，不论是直接还是通配符匹配到的， `&lt;dest&gt;` 必须是一个目录，且以斜杠`/`结尾。
-  如果 `&lt;dest&gt;` 不以斜杠结尾，那么就会被认为是一个普通文件，那么`&lt;src&gt;` 会被写到`&lt;dest&gt;`。
-  如果 `&lt;dest&gt;` 不存在，那么path中的所有未创建的目录都会自动创建。

如果`src`内容改变了，在第一次遇到`COPY`指令后，会禁用后续所有指令的缓存，包括`RUN`指令的缓存。

## ENTRYPOINT

*exec* 格式

&#39;&#39;&#39;
ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
</pre></div>
</div>
<p><em>shell</em> 格式</p>
<p>’’’ ENTRYPOINT command param1 param2</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`ENTRYPOINT`用来配置container作为可执行文件来运行。

示例，使用默认内容启动nginx，监听80端口，

&#39;&#39;&#39;
$ docker run -i -t --rm -p 80:80 nginx
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">&lt;image&gt;</span></code>的命令行参数，会被添加到<em>exec</em>格式中的所有元素之后，并覆盖<code class="docutils literal notranslate"><span class="pre">CMD</span></code>指令定义的元素。这样就可以把参数传递给entry
point，也就是<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">&lt;image&gt;</span> <span class="pre">-d</span></code>会把<code class="docutils literal notranslate"><span class="pre">-d</span></code>传递给entry
point。可以使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">--entrypoint</span></code>来覆盖<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>指令（但是只能把binary设置为exec，不能用<code class="docutils literal notranslate"><span class="pre">sh</span> <span class="pre">-c</span></code>）。</p>
<p><code class="docutils literal notranslate"><span class="pre">shell</span></code>格式会禁用掉<code class="docutils literal notranslate"><span class="pre">CMD</span></code>或者<code class="docutils literal notranslate"><span class="pre">run</span></code>命令行参数，但是有个缺点就是，<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>就不是作为<code class="docutils literal notranslate"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code>的子命令来启动的了，也就是不能传递signals。也就意味着可执行文件，不是container的<code class="docutils literal notranslate"><span class="pre">PID</span> <span class="pre">1</span></code>，也不会接收Unix
signals（一种软件中断）。这样可执行文件就不会接收来自<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">&lt;container&gt;</span></code>的<code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code>。</p>
<p>只有<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>的最后一个<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>才会生效。</p>
<div class="section" id="entrypoint-exec">
<h3>ENTRYPOINT Exec示例<a class="headerlink" href="#entrypoint-exec" title="Permalink to this headline">¶</a></h3>
<p>’’’ FROM ubuntu ENTRYPOINT [“top”, “-b”] CMD [“-c”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>当运行container，`top`是唯一进程，

```shell
$ docker run -it --rm --name test  top -H

top - 08:25:00 up  7:27,  0 users,  load average: 0.00, 0.01, 0.05
Threads:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem:   2056668 total,  1616832 used,   439836 free,    99352 buffers
KiB Swap:  1441840 total,        0 used,  1441840 free.  1324440 cached Mem

  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
    1 root      20   0   19744   2336   2080 R  0.0  0.1   0:00.04 top
</pre></div>
</div>
<p>为了验证更多结果，使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code>，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="m">1</span>  <span class="m">2</span>.6  <span class="m">0</span>.1  <span class="m">19752</span>  <span class="m">2352</span> ?        Ss+  <span class="m">08</span>:24   <span class="m">0</span>:00 top -b -H
root         <span class="m">7</span>  <span class="m">0</span>.0  <span class="m">0</span>.1  <span class="m">15572</span>  <span class="m">2164</span> ?        R+   <span class="m">08</span>:25   <span class="m">0</span>:00 ps aux
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">top</span> <span class="pre">-b</span> <span class="pre">-H</span></code>，其中<code class="docutils literal notranslate"><span class="pre">top</span> <span class="pre">-b</span></code>是<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>设置的，<code class="docutils literal notranslate"><span class="pre">-H</span></code>是docker命令行参数，添加到了<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>后面，覆盖了<code class="docutils literal notranslate"><span class="pre">CMD</span></code>的<code class="docutils literal notranslate"><span class="pre">-c。</span></code></p>
<p>然后可以优雅地使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">test</span></code>请求<code class="docutils literal notranslate"><span class="pre">top</span></code> shut down。</p>
<p>示例，使用<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>在前台运行Apache（也就是<code class="docutils literal notranslate"><span class="pre">PID</span> <span class="pre">1</span></code>），</p>
<p>’’’ FROM debian:stable RUN apt-get update &amp;&amp; apt-get install -y
–force-yes apache2 EXPOSE 80 443 VOLUME [“/var/www”, “/var/log/apache2”,
“/etc/apache2”] ENTRYPOINT [“/usr/sbin/apache2ctl”, “-D”, “FOREGROUND”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果想编写单个可执行文件的启动脚本，可以使用`exec`和`gosu`命令，来确保可执行文件能够接收到Unix signals。

```shell
#!/usr/bin/env bash
set -e

if [ &quot;$1&quot; = &#39;postgres&#39; ]; then
    chown -R postgres &quot;$PGDATA&quot;

    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then
        gosu postgres initdb
    fi

    exec gosu postgres &quot;$@&quot;
fi

exec &quot;$@&quot;
</pre></div>
</div>
<p>最后，如果在shutdown的时候需要做一些额外的清理（或者和其他containers交互），或者是多个协调而不是单个可执行文件，就可能需要确保<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>脚本能够接收Unix
signals，传递，然后做更多工作，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="c1">## Note: I&#39;ve written this using sh so it works in the busybox container too</span>

<span class="c1">## USE the trap if you need to also do manual cleanup after the service is stopped,</span>
<span class="c1">##     or need to start multiple services in the one container</span>
<span class="nb">trap</span> <span class="s2">&quot;echo TRAPed signal&quot;</span> HUP INT QUIT TERM

<span class="c1">## start service in background here</span>
/usr/sbin/apachectl start

<span class="nb">echo</span> <span class="s2">&quot;[hit enter key to exit] or run &#39;docker stop &lt;container&gt;&#39;&quot;</span>
<span class="nb">read</span>

<span class="c1">## stop service and clean up here</span>
<span class="nb">echo</span> <span class="s2">&quot;stopping apache&quot;</span>
/usr/sbin/apachectl stop

<span class="nb">echo</span> <span class="s2">&quot;exited </span><span class="nv">$0</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>如果使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-it</span> <span class="pre">--rm</span> <span class="pre">-p</span> <span class="pre">80:80</span> <span class="pre">--name</span> <span class="pre">test</span> <span class="pre">apache</span></code>来运行这个image，那么就可以使用<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">exec</span></code>或<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">top</span></code>来验证container处理，然后使用脚本停止Apache，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         <span class="m">1</span>  <span class="m">0</span>.1  <span class="m">0</span>.0   <span class="m">4448</span>   <span class="m">692</span> ?        Ss+  <span class="m">00</span>:42   <span class="m">0</span>:00 /bin/sh /run.sh <span class="m">123</span> cmd cmd2
root        <span class="m">19</span>  <span class="m">0</span>.0  <span class="m">0</span>.2  <span class="m">71304</span>  <span class="m">4440</span> ?        Ss   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
www-data    <span class="m">20</span>  <span class="m">0</span>.2  <span class="m">0</span>.2 <span class="m">360468</span>  <span class="m">6004</span> ?        Sl   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
www-data    <span class="m">21</span>  <span class="m">0</span>.2  <span class="m">0</span>.2 <span class="m">360468</span>  <span class="m">6000</span> ?        Sl   <span class="m">00</span>:42   <span class="m">0</span>:00 /usr/sbin/apache2 -k start
root        <span class="m">81</span>  <span class="m">0</span>.0  <span class="m">0</span>.1  <span class="m">15572</span>  <span class="m">2140</span> ?        R+   <span class="m">00</span>:44   <span class="m">0</span>:00 ps aux

$ docker top <span class="nb">test</span>

PID                 USER                COMMAND
<span class="m">10035</span>               root                <span class="o">{</span>run.sh<span class="o">}</span> /bin/sh /run.sh <span class="m">123</span> cmd cmd2
<span class="m">10054</span>               root                /usr/sbin/apache2 -k start
<span class="m">10055</span>               <span class="m">33</span>                  /usr/sbin/apache2 -k start
<span class="m">10056</span>               <span class="m">33</span>                  /usr/sbin/apache2 -k start

$ /usr/bin/time docker stop <span class="nb">test</span>

<span class="nb">test</span>
real    0m <span class="m">0</span>.27s
user    0m <span class="m">0</span>.03s
sys 0m <span class="m">0</span>.03s
</pre></div>
</div>
<p>shell格式会调用command
shell，而exec格式不会，所以exec中<code class="docutils literal notranslate"><span class="pre">$HOME</span></code>是没用的，要用的话直接执行shell
<code class="docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">[</span> <span class="pre">&quot;sh&quot;,</span> <span class="pre">&quot;-c&quot;,</span> <span class="pre">&quot;echo</span> <span class="pre">$HOME&quot;</span> <span class="pre">]</span></code>。</p>
<p>注意，exec格式被解析为JSON数组，所以只能用双引号。还需注意反斜杠。</p>
</div>
<div class="section" id="entrypoint-shell">
<h3>ENTRYPOINT Shell示例<a class="headerlink" href="#entrypoint-shell" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>定义一个简单的string，然后它就会在<code class="docutils literal notranslate"><span class="pre">/bin/sh</span> <span class="pre">-c</span></code>中执行。shell格式使用shell
processing来替代shell environment
variables，然后会忽略任何<code class="docutils literal notranslate"><span class="pre">CMD</span></code>或<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>命令行参数。为了确保<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span></code>能直接signal任何运行的<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>可执行文件，记住使用<code class="docutils literal notranslate"><span class="pre">exec</span></code>开始，</p>
<p>’’’ FROM ubuntu ENTRYPOINT exec top -b</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>运行这个image时，你会看到单个`PID 1`进程，

```shell
$ docker run -it --rm --name test top

Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached
CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq
Load average: 0.08 0.03 0.05 2/98 6
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    1     0 root     R     3164   0%   0% top -b
</pre></div>
</div>
<p>执行<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span></code>，也会干净的退出，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ /usr/bin/time docker stop <span class="nb">test</span>

<span class="nb">test</span>
real    0m <span class="m">0</span>.20s
user    0m <span class="m">0</span>.02s
sys 0m <span class="m">0</span>.04s
</pre></div>
</div>
<p>如果忘了在<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>前添加<code class="docutils literal notranslate"><span class="pre">exec</span></code>，</p>
<p>’’’ FROM ubuntu ENTRYPOINT top -b CMD –ignored-param1</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>运行（为下一步设置一个name），

```shell
$ docker run -it --name test top --ignored-param2

Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached
CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq
Load average: 0.01 0.02 0.05 2/101 7
  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND
    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2
    7     1 root     R     3164   0%   0% top -b
</pre></div>
</div>
<p>你就会看到<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>定义的<code class="docutils literal notranslate"><span class="pre">top</span></code>不是<code class="docutils literal notranslate"><span class="pre">PID</span> <span class="pre">1</span></code>。</p>
<p>如果执行<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">stop</span> <span class="pre">test</span></code>，container就不会干净地退出。<code class="docutils literal notranslate"><span class="pre">stop</span></code>命令会在超时后被强制发送一个<code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it <span class="nb">test</span> ps aux

PID   USER     COMMAND
    <span class="m">1</span> root     /bin/sh -c top -b cmd cmd2
    <span class="m">7</span> root     top -b
    <span class="m">8</span> root     ps aux

$ /usr/bin/time docker stop <span class="nb">test</span>

<span class="nb">test</span>
real    0m <span class="m">10</span>.19s
user    0m <span class="m">0</span>.04s
sys 0m <span class="m">0</span>.03s
</pre></div>
</div>
<p>real 10.19s超时。</p>
</div>
<div class="section" id="cmdentrypoint">
<h3>CMD和ENTRYPOINT如何结合使用<a class="headerlink" href="#cmdentrypoint" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">CMD</span></code>和<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>指令都定义了运行container时，哪些命令会执行。他们的结合有一些规则，</p>
<ol class="arabic simple">
<li><p>Dockerfile应该定义至少一个<code class="docutils literal notranslate"><span class="pre">CMD</span></code> 或<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 。</p></li>
<li><p>如果使用container作为可执行文件，应该定义<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code> 。</p></li>
<li><p>如果需要给<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>
定义默认参数，或者在container中执行ad-hoc（临时）命令，应该使用<code class="docutils literal notranslate"><span class="pre">CMD</span></code>。</p></li>
<li><p>以可选参数运行container时会覆盖<code class="docutils literal notranslate"><span class="pre">CMD</span></code> 。</p></li>
</ol>
<p>下面这个表格展示了<code class="docutils literal notranslate"><span class="pre">CMD</span></code>和<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>指令的不同组合</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 19%" />
<col style="width: 22%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>No
ENTRYPOINT</p></th>
<th class="head"><p>ENTRYPOINT
exec_entry
p1_entry</p></th>
<th class="head"><p>ENTRYPOINT
[“exec_entry”,
“p1_entry”]</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>No CMD</strong></p></td>
<td><p><em>error, not
allowed</em></p></td>
<td><p>/bin/sh -c
exec_entry
p1_entry</p></td>
<td><p>exec_entry p1_entry</p></td>
</tr>
<tr class="row-odd"><td><p><strong>CMD
[“exec_cmd”,
“p1_cmd”]</strong></p></td>
<td><p>exec_cmd
p1_cmd</p></td>
<td><p>/bin/sh -c
exec_entry
p1_entry</p></td>
<td><p>exec_entry p1_entry
exec_cmd p1_cmd</p></td>
</tr>
<tr class="row-even"><td><p><strong>CMD
[“p1_cmd”,
“p2_cmd”]</strong></p></td>
<td><p>p1_cmd
p2_cmd</p></td>
<td><p>/bin/sh -c
exec_entry
p1_entry</p></td>
<td><p>exec_entry p1_entry
p1_cmd p2_cmd</p></td>
</tr>
<tr class="row-odd"><td><p><strong>CMD
exec_cmd
p1_cmd</strong></p></td>
<td><p>/bin/sh -c
exec_cmd
p1_cmd</p></td>
<td><p>/bin/sh -c
exec_entry
p1_entry</p></td>
<td><p>exec_entry p1_entry
/bin/sh -c exec_cmd
p1_cmd</p></td>
</tr>
</tbody>
</table>
<p>注意，如果<code class="docutils literal notranslate"><span class="pre">CMD</span></code>是从base
image定义的，那么设置<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>会重置<code class="docutils literal notranslate"><span class="pre">CMD</span></code>为空值。此时如果要使用<code class="docutils literal notranslate"><span class="pre">CMD</span></code>，必须在当前image重新定义。</p>
</div>
</div>
<div class="section" id="volume">
<h2>VOLUME<a class="headerlink" href="#volume" title="Permalink to this headline">¶</a></h2>
<p>’’’ VOLUME [“/data”]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`VOLUME`指令用来创建挂载点，把container挂载到native host（宿主机）或其他container。

![](012003-【Golang】Dockerfile文件万字全面解析/types-of-mounts-volume_副本.png)

value可以是JSON array，如`VOLUME [&quot;/var/log/&quot;]`，也可以是string，如`VOLUME /var/log`或`VOLUME /var/log /var/db`。

`docker run`命令会用base image中定义的location中存在的任何数据，来初始化新创建的volumn。

示例，

&#39;&#39;&#39;
FROM ubuntu
RUN mkdir /myvol
RUN echo &quot;hello world&quot; &gt; /myvol/greeting
VOLUME /myvol
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span></code>会在<code class="docutils literal notranslate"><span class="pre">/myvol</span></code>创建一个挂载点，然后把<code class="docutils literal notranslate"><span class="pre">greeting</span></code>复制到新创建的volumn。</p>
<p>遵循规则，</p>
<ul class="simple">
<li><p><strong>基于Windows的containers</strong>: volumn的目标路径必须是以下之一:</p>
<ul>
<li><p>不存在的或者空的目录</p></li>
<li><p>除 <code class="docutils literal notranslate"><span class="pre">C:</span></code>以外的驱动</p></li>
</ul>
</li>
<li><p><strong>在Dockerfile里面修改volumn</strong>: 在volumn已经被声明之后的任何build
steps尝试修改volumn数据，都会被忽略。</p></li>
<li><p><strong>JSON formatting</strong>: 要用双引号，不要用单引号.</p></li>
<li><p><strong>在container run-time才会声明主机目录（挂载点）</strong>:
挂载点是依赖主机的。因为主机目录不能保证对所有主机都是有用的，为了保证image的可移植性，不能在Dockerfile中挂载主机目录，而是必须在创建或运行container的时候。<code class="docutils literal notranslate"><span class="pre">VOLUME</span></code>指令也不支持<code class="docutils literal notranslate"><span class="pre">host-dir</span></code>这样的参数。</p></li>
</ul>
</div>
<div class="section" id="user">
<h2>USER<a class="headerlink" href="#user" title="Permalink to this headline">¶</a></h2>
<p>’’’ USER [:]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">或</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">USER &lt;UID&gt;[:&lt;GID&gt;]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">USER</span></code>指令用于<code class="docutils literal notranslate"><span class="pre">RUN</span></code>, <code class="docutils literal notranslate"><span class="pre">CMD</span></code>
和<code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>指令执行时指定user name /
group。<code class="docutils literal notranslate"><span class="pre">USER</span></code>指令可以设置user name（或UID），可选用user
group（或GID）。</p>
<p>如果定义了user
group，那么这个user就只有这个group的membership，任何其他配置的group
memberships都会被忽略。</p>
<p>如果user没有primary group，那么image（或者下一条指令）就会以<code class="docutils literal notranslate"><span class="pre">root</span></code>
group运行。</p>
<p>在Windows，如果不是内建账号，必须先创建。可以在Dockerfile中调用<code class="docutils literal notranslate"><span class="pre">net</span> <span class="pre">user</span></code>命令，</p>
<p>’’’ FROM microsoft/windowsservercore ## Create Windows user in the
container RUN net user /add patrick ## Set it for subsequent commands
USER patrick</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## WORKDIR</span>

<span class="s1">&#39;&#39;&#39;</span>
<span class="s1">WORKDIR /path/to/workdir</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>为<code class="docutils literal notranslate"><span class="pre">RUN</span></code>, <code class="docutils literal notranslate"><span class="pre">CMD</span></code>, <code class="docutils literal notranslate"><span class="pre">ENTRYPOINT</span></code>, <code class="docutils literal notranslate"><span class="pre">COPY</span></code> and
<code class="docutils literal notranslate"><span class="pre">ADD</span></code>指令设置工作目录。</p>
<p>如果<code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>不存在，即使后面的Dockerfile不会用到，它仍然会被创建。</p>
<p><code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>指令可以在Dockerfile中定义多次。如果是相对路径，那么就是相对于上一条<code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code>指令的路径。</p>
<p>示例，</p>
<p>’’’ WORKDIR /a WORKDIR b WORKDIR c RUN pwd</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`pwd`的结果是`/a/b/c`。

`WORKDIR`可以引用`ENV`定义的环境变量，示例，

&#39;&#39;&#39;
ENV DIRPATH /path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pwd</span></code>的结果是<code class="docutils literal notranslate"><span class="pre">/path/$DIRNAME</span></code>。</p>
</div>
<div class="section" id="arg">
<h2>ARG<a class="headerlink" href="#arg" title="Permalink to this headline">¶</a></h2>
<p>’’’ ARG [=</p>
<default value><p>]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`ARG`指令定义变量，用户可以在使用`docker build`命令带参数`--build-arg &lt;varname&gt;=&lt;value&gt;`，在build-time传递这个变量给builder。如果用户指定了一个build参数而没有在Dockerfile中定义，build会报warning，

```shell
[Warning] One or more build-args [foo] were not consumed.
</pre></div>
</div>
<p>一个Dockerfile可以包含一个或多个<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令。</p>
<p>示例，</p>
<p>’’’ FROM busybox ARG user1 ARG buildno ## …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>警告！不建议使用build-time变量来传递私密数据，如github keys，用户认证信息等。因为image的任何用户都可以使用`docker history`查看build-time变量。

### 默认值

`ARG`指令可以设置默认值（可选），

&#39;&#39;&#39;
FROM busybox
ARG user1=someuser
ARG buildno=1
## ...
</pre></div>
</div>
<p>如果<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令有默认值，在build-time没有值传递，那么builder会用这个默认值。</p>
<div class="section" id="id5">
<h3>范围<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令是在它被定义那一行生效的，而不是命令行被使用的时候，或者其他地方。</p>
<p>示例，</p>
<p>’’’ FROM busybox USER ${user:-some_user} ARG user USER $user ## …</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>用户build这个文件，调用，

```shell
$ docker build --build-arg user=what_user .
</pre></div>
</div>
<p>第2行的<code class="docutils literal notranslate"><span class="pre">USER</span></code>结果为<code class="docutils literal notranslate"><span class="pre">some_user</span></code>因为<code class="docutils literal notranslate"><span class="pre">user</span></code>变量是在第3行定义的。</p>
<p>第4行的<code class="docutils literal notranslate"><span class="pre">USER</span></code>结果为<code class="docutils literal notranslate"><span class="pre">what_user</span></code>，因为<code class="docutils literal notranslate"><span class="pre">user</span></code>变量已经被定义了，在命令行传递了<code class="docutils literal notranslate"><span class="pre">what_user</span></code>值。</p>
<p>在<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令定义之前，任何变量使用结果都是空string。</p>
<p>在<code class="docutils literal notranslate"><span class="pre">ARG</span></code>定义的build
stage结束时，<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令就超出范围了。为了在多个stages使用同一个arg，每个stage都必须包括<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令，</p>
<p>’’’ FROM busybox ARG SETTINGS RUN ./run/setup $SETTINGS</p>
<p>FROM busybox ARG SETTINGS RUN ./run/other $SETTINGS</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>### 使用ARG变量

可以使用`ARG`或`ENV`指令来为`RUN`指令定义变量。`ENV`定义的环境变量始终都会覆盖`ARG`定义的同名变量。

示例，

&#39;&#39;&#39;
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER v1.0.0
RUN echo $CONT_IMG_VER
</pre></div>
</div>
<p>假设使用这条命令build image，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$ docker build --build-arg <span class="nv">CONT_IMG_VER</span><span class="o">=</span>v2.0.1 .
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RUN</span></code>会使用<code class="docutils literal notranslate"><span class="pre">v1.0.0</span></code>而不是<code class="docutils literal notranslate"><span class="pre">ARG</span></code>传递的<code class="docutils literal notranslate"><span class="pre">v2.0.1</span></code>。这个行为有点类似于shell脚本，一个局部变量会覆盖通过参数传递的变量，或者从环境定义继承的变量。</p>
<p>还是上面的例子，定义不同的<code class="docutils literal notranslate"><span class="pre">ENV</span></code>会把<code class="docutils literal notranslate"><span class="pre">ARG</span></code>和<code class="docutils literal notranslate"><span class="pre">ENV</span></code>结合的更好用，</p>
<p>’’’ FROM ubuntu ARG CONT_IMG_VER ENV CONT_IMG_VER
${CONT_IMG_VER:-v1.0.0} RUN echo $CONT_IMG_VER</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>不像`ARG`，`ENV`的值会在build image中持久化。如果不用`--build-arg` build，

```shell
$ docker build .
</pre></div>
</div>
<p>用这个Dockerfile，<code class="docutils literal notranslate"><span class="pre">CONT_IMG_VER</span></code>仍然会持久化在这个image，它的值是<code class="docutils literal notranslate"><span class="pre">v1.0.0</span></code>，因为在第3行用<code class="docutils literal notranslate"><span class="pre">ENV</span></code>定义了默认值。</p>
<p>在这个示例中，通过<code class="docutils literal notranslate"><span class="pre">ENV</span></code>指令，可以把命令行参数传递进来，然后持久化到最终的image，实现了变量扩展。变量扩展只支持Dockerfile指令的一部分指令。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADD</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COPY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ENV</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">EXPOSE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FROM</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LABEL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">STOPSIGNAL</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USER</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VOLUME</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WORKDIR</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code> (结合以上指令使用)</p></li>
</ul>
</div>
<div class="section" id="args">
<h3>预定义ARGs<a class="headerlink" href="#args" title="Permalink to this headline">¶</a></h3>
<p>Docker有一些预定义的<code class="docutils literal notranslate"><span class="pre">ARG</span></code>变量，你可以不使用<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令，直接用这些变量。</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">http_proxy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HTTPS_PROXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">https_proxy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FTP_PROXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ftp_proxy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NO_PROXY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">no_proxy</span></code></p></li>
</ul>
<p>直接在命令行使用，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>--build-arg &lt;varname&gt;<span class="o">=</span>&lt;value&gt;
</pre></div>
</div>
<p>默认这些预定义的变量是不会输出到<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">history</span></code>中的。这样可以降低在<code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>变量中意外泄露敏感认证信息的风险。</p>
<p>示例，使用<code class="docutils literal notranslate"><span class="pre">--build-arg</span> <span class="pre">HTTP_PROXY=http://user:pass&#64;proxy.lon.example.com</span></code>来build
Dockerfile，</p>
<p>’’’ FROM ubuntu RUN echo “Hello World”</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`HTTP_PROXY`变量不会输出到`docker history`，也不会被缓存。如果代理服务器变成了`http://user:pass@proxy.sfo.example.com`，后续的build不会导致cache miss。

可以使用`ARG`来覆盖这个默认行为，

&#39;&#39;&#39;
FROM ubuntu
ARG HTTP_PROXY
RUN echo &quot;Hello World&quot;
</pre></div>
</div>
<p>当build这个Dockerfile的时候，<code class="docutils literal notranslate"><span class="pre">HTTP_PROXY</span></code>会存到<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">history</span></code>中，如果它的值改变了，会把build缓存禁用掉。</p>
</div>
<div class="section" id="id6">
<h3>对缓存的影响<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ARG</span></code>变量并不会像<code class="docutils literal notranslate"><span class="pre">ENV</span></code>持久化到image，但是会以类似的方式，影响到build缓存。如果Dockerfile定义了一个<code class="docutils literal notranslate"><span class="pre">ARG</span></code>变量，这个变量和前一个build不一样，那么在第一次用这个变量的时候会发生“cache
miss”（不是定义的时候）。尤其是，所有<code class="docutils literal notranslate"><span class="pre">ARG</span></code>后面的<code class="docutils literal notranslate"><span class="pre">RUN</span></code>指令一般都会使用<code class="docutils literal notranslate"><span class="pre">ARG</span></code>变量，这样就会导致cache
miss。但是所有预定义ARGs是没有影响cache的，除非是在Dockerfile中有一个同名的<code class="docutils literal notranslate"><span class="pre">ARG</span></code>指令。</p>
<p>示例，2个Dockerfile</p>
<p>’’’ FROM ubuntu ARG CONT_IMG_VER RUN echo $CONT_IMG_VER</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">FROM ubuntu</span>
<span class="s1">ARG CONT_IMG_VER</span>
<span class="s1">RUN echo hello</span>
</pre></div>
</div>
<p>如果在命令行指定<code class="docutils literal notranslate"><span class="pre">--build-arg</span> <span class="pre">CONT_IMG_VER=&lt;value&gt;</span></code>，以上2个示例在第2行都不会cache
miss，第3行会cache
miss。<code class="docutils literal notranslate"><span class="pre">ARG</span> <span class="pre">CONT_IMG_VER</span></code>会导致RUN那一行被认为是执行了<code class="docutils literal notranslate"><span class="pre">CONT_IMG_VER=&lt;value&gt;</span></code>
echo hello，所以如果<code class="docutils literal notranslate"><span class="pre">&lt;value&gt;</span></code>改变了，就cache miss了。</p>
<p>另外一个示例，</p>
<p>’’’ FROM ubuntu ARG CONT_IMG_VER ENV CONT_IMG_VER $CONT_IMG_VER RUN echo
$CONT_IMG_VER</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>第3行会发生cache miss。因为`ENV`引用的`ARG`变量通过命令行改变了。另外，在这个示例中，`ENV`会导致image包含这个value（`ENV`会持久化到image中）。

如果`ENV`和`ARG`指令重复，

&#39;&#39;&#39;
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER hello
RUN echo $CONT_IMG_VER
</pre></div>
</div>
<p>第3行就不会发生cache
miss，因为<code class="docutils literal notranslate"><span class="pre">CONT_IMG_VER</span></code>的值是常量（<code class="docutils literal notranslate"><span class="pre">hello</span></code>）。因此第4行<code class="docutils literal notranslate"><span class="pre">RUN</span></code>指令用到的环境变量和值在build之间不会改变。</p>
</div>
</div>
<div class="section" id="onbuild">
<h2>ONBUILD<a class="headerlink" href="#onbuild" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ONBUILD</span> <span class="o">&lt;</span><span class="n">INSTRUCTION</span><span class="o">&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code>指令会在image中添加一个<em>trigger</em>，这个trigger会在image作为base的时候触发。trigger会在下游的
build context中执行，就像在下游的<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code> 中，在
<code class="docutils literal notranslate"><span class="pre">FROM</span></code>指令之后，它就已经被立即嵌入了。</p>
<p>任何build指令都可以注册为trigger。</p>
<p>如果你build一个image，这个image会作为base来build其他images，这就很有用。比如，一个应用build环境或者一个deamon自定义配置。</p>
<p>示例，如果一个image是可复用的Python应用builder（用来build新的应用image），那么它需要把应用源码添加到一个特定目录，然后调用build脚本。此时<code class="docutils literal notranslate"><span class="pre">ADD</span></code>和<code class="docutils literal notranslate"><span class="pre">RUN</span></code>指令是无法访问应用源码的，每个应用build的源码也可能不一样。你可以简单地，给应用开发者提供<code class="docutils literal notranslate"><span class="pre">Dockerfile</span></code>样本文件来复制粘贴到他们的应用中，但这是低效、易出错和困难去做更新的，因为这个和“应用定义”代码混淆了。</p>
<p>可以使用<code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code>指令来提前注册指令，在下个build stage再运行。</p>
<p>过程如下，</p>
<ol class="arabic simple">
<li><p>当碰到<code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code>
指令，builder就会添加trigger到正在build的image的metadata。这条指令不会影响当前build。</p></li>
<li><p>在build的最后，所有的triggers都会被存储到image的manifest，在key
<code class="docutils literal notranslate"><span class="pre">OnBuild</span></code>下面。可以用 <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">inspect</span></code> 命令查看。</p></li>
<li><p>然后image可能会被用来作为新build的base，使用 <code class="docutils literal notranslate"><span class="pre">FROM</span></code> 指令。 <code class="docutils literal notranslate"><span class="pre">FROM</span></code>
指令在处理时，下游builder会查找 <code class="docutils literal notranslate"><span class="pre">ONBUILD</span></code>
triggers，然后按它们注册的顺序执行。如果有trigger失败了，<code class="docutils literal notranslate"><span class="pre">FROM</span></code>指令就会中断，build失败。如果triggers都成功了，那么<code class="docutils literal notranslate"><span class="pre">FROM</span></code>会完成，build成功。</p></li>
<li><p>Triggers会在执行后，从最后一个image中清除。也就是说，它们是不会随着“父子”build继承的。</p></li>
</ol>
<p>比如你可能会添加这样的内容，</p>
<p>’’’ ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build –dir
/app/src</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>注意，1.链式`ONBUILD ONBUILD`是不允许的。2.`ONBUILD`可能不会trigger `FROM` 或 `MAINTAINER`指令。

## STOPSIGNAL

&#39;&#39;&#39;
STOPSIGNAL signal
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">STOPSIGNAL</span></code>指令设置system call
signal，发送到container退出。signal可以是有效的unsigned
number（匹配kernel’s syscall
table里的position，比如9），也可以是SIGNAME（比如SIGKILL）。</p>
</div>
<div class="section" id="healthcheck">
<h2>HEALTHCHECK<a class="headerlink" href="#healthcheck" title="Permalink to this headline">¶</a></h2>
<p>2种格式，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">[OPTIONS]</span> <span class="pre">CMD</span> <span class="pre">command</span></code>
(通过运行container里面的命令来检查container)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">NONE</span></code> (禁用健康检查，从base image继承)</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code>指令用来告诉Docker怎样测试container是否还在工作。比如虽然server一直在运行，但是实际上已经死循环了，无法处理新连接了。</p>
<p>当container定义了健康检查，就会把健康状态添加到status中。status初始化是<code class="docutils literal notranslate"><span class="pre">starting</span></code>。无论健康检查什么时候通过，它都会变为<code class="docutils literal notranslate"><span class="pre">healthy</span></code>（无论之前是什么状态）。在一定数量的连续失败后，它会变为<code class="docutils literal notranslate"><span class="pre">unhealthy</span></code>。</p>
<p>第一种格式的<code class="docutils literal notranslate"><span class="pre">OPTION</span></code>可以是，</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">--interval=DURATION</span></code> (default: <code class="docutils literal notranslate"><span class="pre">30s</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--timeout=DURATION</span></code> (default: <code class="docutils literal notranslate"><span class="pre">30s</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--start-period=DURATION</span></code> (default: <code class="docutils literal notranslate"><span class="pre">0s</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--retries=N</span></code> (default: <code class="docutils literal notranslate"><span class="pre">3</span></code>)</p></li>
</ul>
<p>在container开始后的<strong>interval</strong> seconds
，会运行健康检查。每个健康检查完成后，等待<strong>interval</strong>
seconds再次运行。</p>
<p>如果健康检查运行的时候超过了<strong>timeout</strong> seconds，就认为失败。</p>
<p>失败的次数如果达到了<strong>retries</strong>的值，就认为<code class="docutils literal notranslate"><span class="pre">unhealthy</span></code>。</p>
<p><strong>start period</strong>指定了container需要启动的时间。在这期间探针失败（Probe
failure）不会记作重试次数。但是，如果在这期间健康检查通过了，那么container就认为已经启动了，这之后的失败（all
consecutive failures）就会记作重试次数。</p>
<p>一个Dockerfile只能有一个<code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code>指令。如果有多个，那么只有最后一个<code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span></code>生效。</p>
<p>第1种格式的<code class="docutils literal notranslate"><span class="pre">command</span></code>既可以是<em>shell</em>命令（如，<code class="docutils literal notranslate"><span class="pre">HEALTHCHECK</span> <span class="pre">CMD</span> <span class="pre">/bin/check-running</span></code>），也可以是<code class="docutils literal notranslate"><span class="pre">exec</span></code>数组。</p>
<p>command的退出状态反应了container的健康状态，</p>
<ul class="simple">
<li><p>0: success - the container is healthy and ready for use</p></li>
<li><p>1: unhealthy - the container is not working correctly</p></li>
<li><p>2: reserved - do not use this exit code</p></li>
</ul>
<p>示例，每5分钟检查1次，以确保web服务器能在3秒内为网站首页提供服务，</p>
<div class="line-block">
<div class="line">’’’ HEALTHCHECK –interval=5m –timeout=3s</div>
<div class="line">CMD curl -f <a class="reference external" href="http://localhost/">http://localhost/</a> || exit 1</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>为了帮助debug失败探针（failing probes），任何写到stdout或stderr输出文本（UTF-8编码）都会被存储到健康状态，并且可以使用`docker inspect`查询。而且输出应该简短（目前只有最开始的4096 bytes会被存储）。

当container的健康状态改变了，会用新的状态生成一个`health_status`事件。

## SHELL

&#39;&#39;&#39;
SHELL [&quot;executable&quot;, &quot;parameters&quot;]
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令允许重写<em>shell</em>格式命令的默认shell。Linux的默认shell是<code class="docutils literal notranslate"><span class="pre">[&quot;/bin/sh&quot;,</span> <span class="pre">&quot;-c&quot;]</span></code>，Windows的默认shell是<code class="docutils literal notranslate"><span class="pre">[&quot;cmd&quot;,</span> <span class="pre">&quot;/S&quot;,</span> <span class="pre">&quot;/C&quot;]</span></code>。<code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令必须在Dockfile中写成JSON格式。</p>
<p><code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令在Windows特别有用，因为Windows有2个常用的不同的原生shell，<code class="docutils literal notranslate"><span class="pre">cmd</span></code>和<code class="docutils literal notranslate"><span class="pre">powershell</span></code>，也有可选用的shell，包括<code class="docutils literal notranslate"><span class="pre">sh</span></code>。</p>
<p><code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令可以出现多次。每个<code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令会覆盖所有之前的<code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令，影响随后的指令。</p>
<p>示例，</p>
<p>’’’ FROM microsoft/windowsservercore</p>
</div>
<div class="section" id="executed-as-cmd-s-c-echo-default">
<h2>Executed as cmd /S /C echo default<a class="headerlink" href="#executed-as-cmd-s-c-echo-default" title="Permalink to this headline">¶</a></h2>
<p>RUN echo default</p>
</div>
<div class="section" id="executed-as-cmd-s-c-powershell-command-write-host-default">
<h2>Executed as cmd /S /C powershell -command Write-Host default<a class="headerlink" href="#executed-as-cmd-s-c-powershell-command-write-host-default" title="Permalink to this headline">¶</a></h2>
<p>RUN powershell -command Write-Host default</p>
</div>
<div class="section" id="executed-as-powershell-command-write-host-hello">
<h2>Executed as powershell -command Write-Host hello<a class="headerlink" href="#executed-as-powershell-command-write-host-hello" title="Permalink to this headline">¶</a></h2>
<p>SHELL [“powershell”, “-command”] RUN Write-Host hello</p>
</div>
<div class="section" id="executed-as-cmd-s-c-echo-hello">
<h2>Executed as cmd /S /C echo hello<a class="headerlink" href="#executed-as-cmd-s-c-echo-hello" title="Permalink to this headline">¶</a></h2>
<p>SHELL [“cmd”, “/S”, “/C”] RUN echo hello</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>当*shell*格式的`RUN`，`  CMD`，`ENTRYPOINT`出现在Dcokerfile中时，`SHELL`指令能影响这些指令。

示例，Windows上常见的模式，可以通过使用SHELL指令进行简化，

&#39;&#39;&#39;
RUN powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;
</pre></div>
</div>
<p>docker调用的命令，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>cmd /S /C powershell -command Execute-MyCmdlet -param1 <span class="s2">&quot;c:\foo.txt&quot;</span>
</pre></div>
</div>
<p>这个有点低效，有2个原因。首先，有一个不必要的cmd.exe命令行处理器（aka
shell）被调用了。其次，<em>shell</em>格式的<code class="docutils literal notranslate"><span class="pre">RUN</span></code>指令需要额外的前缀命令<code class="docutils literal notranslate"><span class="pre">powershell</span> <span class="pre">-command</span></code>。</p>
<p>为了更高效，有2种机制。其一是使用JSON格式，</p>
<p>’’’ RUN [“powershell”, “-command”, “Execute-MyCmdlet”, “-param1
“c:foo.txt””]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>JSON格式是清晰的，不会使用不必要的cmd.exe。但是需要双引号和转义符，显得有点冗余。

。其二是用`SHELL`指令和`shell`格式，这样可以给Windows用户更自然的语法，特别是和`escape` parser directive结合使用的时候，

&#39;&#39;&#39;
## escape=`

FROM microsoft/nanoserver
SHELL [&quot;powershell&quot;,&quot;-command&quot;]
RUN New-Item -ItemType Directory C:\Example
ADD Execute-MyCmdlet.ps1 c:\example\
RUN c:\example\Execute-MyCmdlet -sample &#39;hello world&#39;
</pre></div>
</div>
<p>结果是，</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>PS E:<span class="se">\d</span>ocker<span class="se">\b</span>uild<span class="se">\s</span>hell&gt; docker build -t shell .
Sending build context to Docker daemon <span class="m">4</span>.096 kB
Step <span class="m">1</span>/5 : FROM microsoft/nanoserver
 ---&gt; 22738ff49c6d
Step <span class="m">2</span>/5 : SHELL powershell -command
 ---&gt; Running in 6fcdb6855ae2
 ---&gt; 6331462d4300
Removing intermediate container 6fcdb6855ae2
Step <span class="m">3</span>/5 : RUN New-Item -ItemType Directory C:<span class="se">\E</span>xample
 ---&gt; Running in d0eef8386e97


    Directory: C:<span class="se">\</span>


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----       <span class="m">10</span>/28/2016  <span class="m">11</span>:26 AM                Example


 ---&gt; 3f2fbf1395d9
Removing intermediate container d0eef8386e97
Step <span class="m">4</span>/5 : ADD Execute-MyCmdlet.ps1 c:<span class="se">\e</span>xample<span class="se">\</span>
 ---&gt; a955b2621c31
Removing intermediate container b825593d39fc
Step <span class="m">5</span>/5 : RUN c:<span class="se">\e</span>xample<span class="se">\E</span>xecute-MyCmdlet <span class="s1">&#39;hello world&#39;</span>
 ---&gt; Running in be6d8e63fe75
hello world
 ---&gt; 8e559e9bf424
Removing intermediate container be6d8e63fe75
Successfully built 8e559e9bf424
PS E:<span class="se">\d</span>ocker<span class="se">\b</span>uild<span class="se">\s</span>hell&gt;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令也能被用来修改shell操作方式。比如在Windows用<code class="docutils literal notranslate"><span class="pre">SHELL</span> <span class="pre">cmd</span> <span class="pre">/S</span> <span class="pre">/C</span> <span class="pre">/V:ON|OFF</span></code>，可以修改<a class="reference external" href="%5Bhttps://baike.baidu.com/item/%E5%BB%B6%E8%BF%9F%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%89%A9%E5%B1%95/2259702%5D(https://baike.baidu.com/item/延迟环境变量扩展/2259702)">延迟环境变量扩展</a>语义。</p>
<p><code class="docutils literal notranslate"><span class="pre">SHELL</span></code>指令也可以用在Linux上，可选的shell有<code class="docutils literal notranslate"><span class="pre">zsh</span></code>, <code class="docutils literal notranslate"><span class="pre">csh</span></code>,
<code class="docutils literal notranslate"><span class="pre">tcsh</span></code>等。</p>
</div>
<div class="section" id="dockerfile">
<h2>Dockerfile示例<a class="headerlink" href="#dockerfile" title="Permalink to this headline">¶</a></h2>
<p>’’’ ## Nginx # ## VERSION 0.0.1</p>
<p>FROM ubuntu LABEL Description=“This image is used to start the foobar
executable” Vendor=“ACME Products” Version=“1.0” RUN apt-get update &amp;&amp;
apt-get install -y inotify-tools nginx apache2 openssh-server</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">## Firefox over VNC</span>
<span class="s1">#</span>
<span class="s1">## VERSION               0.3</span>

<span class="s1">FROM ubuntu</span>

<span class="s1">## Install vnc, xvfb in order to create a &#39;fake&#39; display and firefox</span>
<span class="s1">RUN apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span>
<span class="s1">RUN mkdir ~/.vnc</span>
<span class="s1">## Setup a password</span>
<span class="s1">RUN x11vnc -storepasswd 1234 ~/.vnc/passwd</span>
<span class="s1">## Autostart firefox (might not be the best way, but it does the trick)</span>
<span class="s1">RUN bash -c &#39;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#39;</span>

<span class="s1">EXPOSE 5900</span>
<span class="s1">CMD    [&quot;x11vnc&quot;, &quot;-forever&quot;, &quot;-usepw&quot;, &quot;-create&quot;]</span>
</pre></div>
</div>
<p>’’’ ## Multiple images example # ## VERSION 0.1</p>
<p>FROM ubuntu RUN echo foo &gt; bar ## Will output something like ===&gt;
907ad6c2736f</p>
<p>FROM ubuntu RUN echo moo &gt; oink ## Will output something like ===&gt;
695d7793cbe4</p>
</div>
<div class="section" id="youll-now-have-two-images-907ad6c2736f-with-bar-and-695d7793cbe4-with">
<h2>You’ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with<a class="headerlink" href="#youll-now-have-two-images-907ad6c2736f-with-bar-and-695d7793cbe4-with" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="oink">
<h2>/oink.<a class="headerlink" href="#oink" title="Permalink to this headline">¶</a></h2>
<p>```</p>
<p>以下内容可查看参考资料进一步阅读。</p>
<ul class="simple">
<li><p>BuildKit（第三方工具）</p></li>
<li><p>Parser directives的命令syntax（依赖BuildKit）</p></li>
<li><p>RUN已知bug（<a class="reference external" href="https://github.com/docker/docker/issues/783">Issue
783</a>）</p></li>
<li><p>External implementation features（依赖BuildKit）</p></li>
<li><p>Automatic platform ARGs in the global scope（依赖BuildKit）</p></li>
</ul>
<blockquote>
<div><p>参考资料</p>
<p><a class="reference external" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="013001-%E3%80%90UI%E8%87%AA%E5%8A%A8%E5%8C%96%E3%80%91webdriver%E4%BD%BF%E7%94%A8%E5%B7%B2%E6%89%93%E5%BC%80%E8%BF%87%E7%9A%84chrome.html" class="btn btn-neutral float-right" title="【UI自动化】webdriver使用已打开过的chrome" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="012002-%E3%80%90Golang%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E5%8D%95%E6%96%97%E5%9C%B0%E4%B8%BB.html" class="btn btn-neutral float-left" title="【Golang】多线程简单斗地主" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 测试开发体系

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>