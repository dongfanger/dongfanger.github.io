

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>【AI白皮书】AI原生应用的关键要素 &mdash; 测试开发Gang latest documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/js/readmore.js"></script>
        <script src="../_static/js/baidutongji.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="【AI白皮书】AI应用开发框架" href="002003-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html" />
    <link rel="prev" title="【AI白皮书】AI原生应用及其架构" href="002001-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E6%9E%B6%E6%9E%84.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> 测试开发Gang
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../%E5%85%B3%E4%BA%8E%E6%9C%AC%E4%B9%A6.html">关于本书</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../chapters/AI%E6%B5%8B%E8%AF%95.html">AI测试</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="001001-AI%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E6%96%B0%E5%A7%BF%E5%8A%BFMCP%20Python%20SDK.html">AI测试工具开发新姿势MCP Python SDK</a></li>
<li class="toctree-l2"><a class="reference internal" href="002001-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E6%9E%B6%E6%9E%84.html">【AI白皮书】AI原生应用及其架构</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">【AI白皮书】AI原生应用的关键要素</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">2.1 模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">2.1.1 模型分类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">2.1.2 模型能力和微调</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">2.1.3 如何选择模型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">2.2 框架</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#agent">2.2.1 Agent设计模式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.2.2 Agent开发框架</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">2.3 提示词</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">2.3.1 提示词是什么</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ai">2.3.2 提示词质量=AI输出质量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">2.3.3 如何优化提示词</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rag">2.4 RAG</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">2.4.1 RAG知识库的应用架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">2.4.2 RAG知识库的应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">2.4.3 RAG知识库技术的未来发展</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">2.5 记忆</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">2.5.1 记忆的核心作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">2.5.2 短期记忆和长期记忆</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id16">2.6 工具</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">2.6.1 如何调用工具</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mcp">2.6.2 MCP协议</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">2.6.3 工具调用的挑战和发展</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">2.7 网关</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">2.7.1 什么是AI网关</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">2.7.2 统一的模型接入与厂商解耦</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">2.7.3 融合存量系统与AI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">2.7.4 智能路由与故障转移</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">2.7.5 精细化的成本控制与优化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">2.7.6 企业级安全与合规</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id26">2.7.7 数据、观测与优化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id27">2.8 运行时</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id28">2.8.1 什么是AI原生应用的运行时</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">2.8.2 运行时的核心挑战</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aiserverless">2.8.3 面向AI优化的Serverless架构</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id30">2.9 可观测</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">2.10 评估</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id32">2.10.1 构建高质量的数据集</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">2.10.2 明确评估目标</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">2.10.3 搭建完整的自动化评估系统进行评估</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id35">2.11 安全</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="002003-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html">【AI白皮书】AI应用开发框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="002004-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%B7%A5%E7%A8%8B.html">【AI白皮书】上下文工程</a></li>
<li class="toctree-l2"><a class="reference internal" href="002005-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%B7%A5%E5%85%B7.html">【AI白皮书】AI工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="002006-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E7%BD%91%E5%85%B3.html">【AI白皮书】AI网关</a></li>
<li class="toctree-l2"><a class="reference internal" href="002007-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6.html">【AI白皮书】AI应用运行时</a></li>
<li class="toctree-l2"><a class="reference internal" href="002008-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%8F%AF%E8%A7%82%E6%B5%8B.html">【AI白皮书】AI可观测</a></li>
<li class="toctree-l2"><a class="reference internal" href="002009-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E8%AF%84%E4%BC%B0.html">【AI白皮书】AI评估</a></li>
<li class="toctree-l2"><a class="reference internal" href="002010-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%AE%89%E5%85%A8.html">【AI白皮书】AI安全</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Python.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/pytest.html">pytest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Django.html">Django</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Flask.html">Flask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/FastAPI.html">FastAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/HttpRunner.html">HttpRunner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8E%9F%E5%88%9B%E5%B0%8F%E5%B7%A5%E5%85%B7.html">原创小工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8E%9F%E5%88%9B%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6tep.html">原创接口测试框架tep</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8E%9F%E5%88%9B%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0teprunner.html">原创接口测试平台teprunner</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.html">测试报告</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%87%AA%E5%8A%A8%E5%8C%96.html">自动化</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83.html">测试环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE.html">流量回放</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.html">性能测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%A7%BB%E5%8A%A8%E7%AB%AF.html">移动端</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86.html">计算机知识</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E4%B8%AD%E9%97%B4%E4%BB%B6.html">中间件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%AE%97%E6%B3%95.html">算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Java.html">Java</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html">单元测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/JavaWeb%E5%BC%80%E5%8F%91.html">JavaWeb开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Spring%E6%8A%80%E6%9C%AF%E6%A0%88.html">Spring技术栈</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html">白盒测试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/TestNG.html">TestNG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Golang.html">Golang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">读书笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E4%B8%AA%E4%BA%BA%E6%80%9D%E8%80%83.html">个人思考</a></li>
<li class="toctree-l1"><a class="reference internal" href="../%E5%B0%8A%E4%BA%AB%E6%9C%8D%E5%8A%A1.html">尊享服务</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">测试开发Gang</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../chapters/AI%E6%B5%8B%E8%AF%95.html">AI测试</a> &raquo;</li>
        
      <li>【AI白皮书】AI原生应用的关键要素</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/AI测试/002002-【AI白皮书】AI原生应用的关键要素.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="aiai">
<h1>【AI白皮书】AI原生应用的关键要素<a class="headerlink" href="#aiai" title="Permalink to this headline">¶</a></h1>
<p><img alt="image1" src="../_images/wanggang.png" /></p>
<div class="section" id="id1">
<h2>2.1 模型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>大模型扮演着大脑的角色，负责核心的理解、推理与生成任务。</p>
<div class="section" id="id2">
<h3>2.1.1 模型分类<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p><strong>通用大模型</strong>：GPT、Claude、Qwen、DeepSeek、Gemini等通用大模型。</p>
<p><strong>垂直领域模型</strong>：情感分析、语言翻译、意图分类等垂直领域模型。</p>
<p>通用大模型适合处理复杂、开放的任务，垂直领域模型适合处理简单、高频的任务。</p>
</div>
<div class="section" id="id3">
<h3>2.1.2 模型能力和微调<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>模型的知识是固化的，需要不断地“喂”它，把这些信息结构化地描述清楚并且提供给它，它会在每次的交互中动态地理解你提供的内容，并结合自身的通用知识来完成内容的生成。</p>
<p>企业专属模型的训练和微调的成本是巨大的，它不仅包括高昂的计算资源费用，还需要海量的高质量标注数据、专业的算法团队以及漫长的开发周期。对于绝大多企业来说，投入与产出不成正比，很难持续。</p>
</div>
<div class="section" id="id4">
<h3>2.1.3 如何选择模型<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>基于企业的实际业务场景，权衡任务复杂度、性能要求、开发成本和响应延迟等多个因素来综合选择和组合最合适的模型。</p>
<p>一个务实的策略是从顶配开始，逐步优化：先用能力最强的模型搭建原型以验证业务逻辑，再逐步将流程中的非核心、简单任务替换为更经济、更快速的小模型，最终找到成本与性能的最佳平衡点。</p>
</div>
</div>
<div class="section" id="id5">
<h2>2.2 框架<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>Spring或Dubbo开发一个微服务应用，代码确定，容易形成标准化的框架。而开发一个AI
Agent应用，LLM存在高度不确定性，设计模式的落地方式差异很大。</p>
<div class="section" id="agent">
<h3>2.2.1 Agent设计模式<a class="headerlink" href="#agent" title="Permalink to this headline">¶</a></h3>
<p><strong>1、Chain of Thought（思维链）</strong></p>
<p>让模型在回答前，把推理过程一步步写出来。</p>
<p><strong>2、Self-Ask（自问自答）</strong></p>
<p>让模型在回答时学会反问自己，把大问题拆成多个小问题，然后逐个回答。</p>
<p><strong>3、ReAct（推理+行动）</strong></p>
<p>在推理和外部行动（比如调用搜索引擎或API）之间交替进行。</p>
<p><strong>4、Plan-and-Execute（计划与执行）</strong></p>
<p>把任务拆成两个阶段，先生成计划，再逐步执行。</p>
<p><strong>5、Tree of Thoughts（ToT，树状思维）</strong></p>
<p>不是单线思维，而是生成多条思路分支，像树一样展开，再通过评估机制选出最佳分支。</p>
<p><strong>6、Reflexion / Iterative Refinement（反思与迭代优化）</strong></p>
<p>Agent自我纠错，犯错后会总结失败原因，再带着反思尝试下一次。</p>
<p><strong>7、Role-playing Agents（角色扮演式智能体）</strong></p>
<p>把任务拆分给不同角色的Agent，通过对话协作完成任务。</p>
<p>这些模式不是互斥的，可以混搭使用。</p>
<p>其中ReAct已经被LangChain、LlamaIndex、Dify、Spring AI
Alibaba等开发框架内置为基础框架。</p>
</div>
<div class="section" id="id6">
<h3>2.2.2 Agent开发框架<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p><strong>1、从低代码到高代码</strong></p>
<p>低代码平台是对于高代码的一层封装，其抽象层次很难满足所有场景，无法在性能、扩展性和复杂业务逻辑方面满足大规模生产的要求。</p>
<p>高代码是当下AI原生应用生产落地的主流形态，ADK、LangGraph、AutoGen、AgentScope、Spring
AI Alibaba等框架，为开发者提供了面向Agent的编程接口。</p>
<p><strong>2、高代码的演进</strong></p>
<p>高代码模式本身经历了从ChatClient→Workflow→Agentic的演进过程。</p>
<p>ChatClient，一次单一的LLM调用。Workflow，将传统工作流转化为LLM节点编排。Agentic，提供面向Agent的API，并内置多种通用的协作模式（Pattern）。</p>
<p><strong>3、零代码的愿景</strong></p>
<p>尝试让用户完全通过自然语言即可驱动开发。目前处于探索与验证阶段，难以承担大规模生产任务。</p>
</div>
</div>
<div class="section" id="id7">
<h2>2.3 提示词<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>在AI原生应用中，不再编写复杂的代码，而是使用更接近人类语言的方式与AI沟通，这就是Prompt（提示词）。提示词的质量很大程度上影响了AI应用的输出效果。</p>
<div class="section" id="id8">
<h3>2.3.1 提示词是什么<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>提示词可以是一个具体的问题、一段描述、一组关键词，或是相关的上下文，不仅限于自然语言文本，还可以包含代码片段、数据格式说明，甚至是图像与文字相结合的多模态输入。</p>
</div>
<div class="section" id="ai">
<h3>2.3.2 提示词质量=AI输出质量<a class="headerlink" href="#ai" title="Permalink to this headline">¶</a></h3>
<p>大模型的输出质量，既要看大模型本身，也要看提示词是否清晰、完整、具体。比如，“写点关于人工智能的东西”，生成的内容是泛泛而谈。“以科技专栏作家的身份，撰写一篇800字左右的文章，探讨人工智能在医疗影像诊断中的最新应用、优势与挑战，并列举实例”，能生成一篇逻辑严谨、信息详实、专业度高的文章。</p>
</div>
<div class="section" id="id9">
<h3>2.3.3 如何优化提示词<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>开发者需要清晰、有效地与模型交流，并明确指导它如何处理各自情况，在第4章中将围绕上下文工程对提示词展开详细介绍。</p>
</div>
</div>
<div class="section" id="rag">
<h2>2.4 RAG<a class="headerlink" href="#rag" title="Permalink to this headline">¶</a></h2>
<p>RAG（Retrieval Augmented
Generation，检索增强生成）用于构建大模型的知识库。RAG技术能够弥补大模型因知识截止而无法获取最新信息的问题，并有效降低其产生幻觉的风险，而且RAG技术相比于大模型后训练或微调方式，以更加成本低的方式与企业的专有数据作对接，以实现大模型快速技术验证和商业化尝试。</p>
<div class="section" id="id10">
<h3>2.4.1 RAG知识库的应用架构<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p><img alt="image2" src="../_images/2025-11-10-20-53-29-image.png" /></p>
<p>1、离线向量过程：把用户上传的文档进行文档智能解析、切片，再进行向量化存储到向量数据库。</p>
<p>2、在线过程：把用户的请求问题向量化之后与向量库中的切片向量进行相似度对比，从而召回最接近用户问题的相关切片。</p>
<p>一个简单的RAG系统可能会遭遇准确率和召回率的挑战、信息冗余噪声导致的模型幻觉、知识库庞杂难以管理等问题。当前RAG系统的构建也逐步向模块化、Agentic
RAG的高级架构演进。</p>
<p><img alt="image3" src="../_images/2025-11-10-21-30-37-image.png" /></p>
<p>1、离线过程，文档解析技术除了OCR和电子解析技术，也利用大模型进行解析，比如图片类文档使用VLM视觉理解大模型。</p>
<p>2、在线检索过程，检索前、检索中、检索后都发展出很多技术手段，比如检索前增加Query改写、知识库路由等模块，检索过程采用检索策略，检索后增加重排序、拒识模块等。</p>
</div>
<div class="section" id="id11">
<h3>2.4.2 RAG知识库的应用场景<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>客户服务、个性化推荐、AI陪伴、内容创作等。除了简单的问答，基于RAG的系统，叠加大模型分析客户对话数据等能力，能帮助企业优化服务策略和挖掘销售线索等。多模态RAG的兴起，可以在零售电商场景，让用户通过上传图片来检索商品；在媒体娱乐领域，从海量音视频中检索出特定片段，服务于内容分发以及AI视频创作场景。</p>
</div>
<div class="section" id="id12">
<h3>2.4.3 RAG知识库技术的未来发展<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>在当前Advanced
RAG架构里，仍然有许多问题待解决。多模态RAG相关的技术，也还在快速发展当中。RAG系统中的知识库向量检索，也是上下文工程的核心技术实现，在第4章将围绕上下文工程对RAG展开详细的介绍。</p>
</div>
</div>
<div class="section" id="id13">
<h2>2.5 记忆<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>在使用DeepSeek时，查看历史对话，就是AI应用的记忆功能。</p>
<div class="section" id="id14">
<h3>2.5.1 记忆的核心作用<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>大模型本质上是无状态的，AI原生应用引入了记忆组件，从一个单轮问答的机器人，成长为能与我们长期协作、处理复杂任务的智能伙伴。</p>
<p><strong>1、跨越会话的连贯性</strong></p>
<p>长期保存关键信息（如对话历史、任务状态、决策依据），并通过高效的检索与上下文注入机制，在新的交互中动态地为模型提供相关背景。</p>
<p><strong>2、高度自适应的个性化</strong></p>
<p>构建和维护动态的用户画像来实现个性化。系统地记录用户的偏好，如格式要求、沟通风格等，也能记住历史行为模式与长期目标，使模型能够生成高度定制化的输出。</p>
<p><strong>3、基于历史信息的深度推理</strong></p>
<p>借助记忆提供的历史知识和经验充当推理的证据库，当模型在决策时，能关联并整合分散在历史中的相关数据、相似案例或既有结论。</p>
</div>
<div class="section" id="id15">
<h3>2.5.2 短期记忆和长期记忆<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>短期记忆保证了交互的即时性与上下文的完整性，长期记忆则提供跨会话的知识背景。</p>
<p><strong>短期记忆（Short-Term Memory，STM）</strong></p>
<p>模型在单次、连续的交互会话中所能直接访问的信息。</p>
<p><strong>长期记忆（Long-Term Memory，LTM）</strong></p>
<p>让AI能够记住跨越不同会话，甚至数天数月前的信息。系统将需要长期保存的信息，如对话摘要、用户画像或外部文档，进行向量化处理，并存入专门的向量数据库进行索引。当新的交互发生时，系统会根据当前输入的语义，在数据库中高效检索出最相关的历史记忆片段，并将其作为背景知识动态加入到模型的输入中。也就是外部数据库和语义检索的机制。</p>
</div>
</div>
<div class="section" id="id16">
<h2>2.6 工具<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>LLM的知识是静态的，其知识内容截止于其训练数据的最后更新日期。模型本身也无法直接与外部系统交互，执行如发送电子邮件、预定航班或执行数据库查询等实际操作。需要借助工具来实现，工具本质上是可以调用的外部接口。</p>
<div class="section" id="id17">
<h3>2.6.1 如何调用工具<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>大模型本身不能调用工具，它是根据用户的输入和可用工具的描述，智能地判断并决定调用哪个工具以及传递哪些参数。</p>
<p><img alt="image4" src="../_images/2025-11-12-10-12-32-image.png" /></p>
<p>OpenAI率先在其推理API接口中支持了Function
Calling（后升级为Tools），函数调用，核心是让大模型生成调用外部API的结构化入参。开发者预先把工具信息提供给大模型，通常是JSON
Schema形式，包括函数名称、功能描述和参数列表。当用户请求时，大模型分析意图，判断是否需要调用工具以及调用哪个工具，生成一个包含tool_calls字段的结构化JSON对象。应用程序拿到后，就可以解析并调用相应的工具。</p>
</div>
<div class="section" id="mcp">
<h3>2.6.2 MCP协议<a class="headerlink" href="#mcp" title="Permalink to this headline">¶</a></h3>
<p>MCP，Model Context
Protocol，模型上下文协议，是由Anthropic公司2024年推出的，为大模型与外部数据、应用和服务之间的通信提供一种安全且标准化的语言。MCP协议迅速地成为当前大模型供应商的标准协议，包括OpenAI、Google、阿里云百炼在内的模型服务商，都对MCP做了兼容性支持。</p>
<p>MCP服务有很多托管平台，MCP社区为了统一，定义了MCP
Registry，标准化服务器的分发和发现方式，使Agent和工具更容易连接，近期发布了Preview版本，用于公开可用的MCP服务器的开放目录和API。Nacos也开源了Nacos
MCP Registry，定位私有化，方便企业内部部署。</p>
</div>
<div class="section" id="id18">
<h3>2.6.3 工具调用的挑战和发展<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>当前工具调用存在调用时延、工具提取参数准确性、安全鉴权等问题，长远来看都将被有效解决，大模型将更智能地组合和串联多个工具完成更复杂的跨领域任务。</p>
</div>
</div>
<div class="section" id="id19">
<h2>2.7 网关<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>AI网关用来解决模型切换、Token经济、语义缓存和内容风控等AI原生的需求。</p>
<div class="section" id="id20">
<h3>2.7.1 什么是AI网关<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>AI网关是一个专为AI应用设计的、位于应用和大模型之间、应用和工具之间、模型和模型之间的中间件。其核心职责不再仅仅是路由和保护RESTful
API，而是要理解并管理以Token为中心的、高延迟、流式传输的流量。</p>
<p>（AI
Token跟我们常说的登录token不是一个概念，Token翻译过来也可以叫符号，对AI来说是将文本分解后的基本单元，类似于将句子拆分成词汇或字符的过程）</p>
</div>
<div class="section" id="id21">
<h3>2.7.2 统一的模型接入与厂商解耦<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>不同供应商（如OpenAI、Anthropic、DeepSeek）的API标准各异，AI网关需要提供统一规范的API，将所有模型的接口都转换成一个标准的、统一的接口对外服务。开发者无需为新模型编写定制代码，方便进行模型切换、A/B测试和组合模型等。</p>
</div>
<div class="section" id="id22">
<h3>2.7.3 融合存量系统与AI<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>AI网关能通过其协议抽象层扫描REST、GraphQL、gRPC等存量服务的API规范（如Swagger），自动生成符合大模型工具调用（如MCP规范）的描述文件，并借助MCP
Registry注册到统一的服务目录中。这样无需改动存量业务接口的代码，就能将它们升级为“AI-Ready
API”。</p>
</div>
<div class="section" id="id23">
<h3>2.7.4 智能路由与故障转移<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h3>
<p><strong>智能路由</strong>：不仅可以根据请求内容或用户身份分发流量，还可以根据实时的Token单价、延迟、显存占用等权重进行动态推理流量调度，实现成本与性能的最佳平衡。</p>
<p><strong>故障转移</strong>：通过持续监控后端服务健康状态，一旦检测到模型响应缓慢或不可用，便会自动将流量无感切换到备用模型，保障应用的高可用性。</p>
</div>
<div class="section" id="id24">
<h3>2.7.5 精细化的成本控制与优化<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p><strong>语义缓存</strong>：对于内容相似但表述不同的重复问题，可直接返回缓存，避免对昂贵模型的重复调用。</p>
<p><strong>成本与流控</strong>：按组织、用户、应用等维度管理Token预算，当超出限额后，可以自动降级到成本更低的模型，从而有效防止资源滥用和成本超支。</p>
</div>
<div class="section" id="id25">
<h3>2.7.6 企业级安全与合规<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p><strong>安全合规能力</strong>：内置国密算法支持和敏感语料实时过滤等能力。</p>
<p><strong>审计与追溯</strong>：所有流经网关的Prompt、Response、Token消耗量等数据都会记录，以满足实时审计和追溯等合规要求。</p>
<p><strong>统一身份认证</strong>：与企业内部自有的身份授权基础设施对接，对AI生态提供统一的认证授权切面。</p>
</div>
<div class="section" id="id26">
<h3>2.7.7 数据、观测与优化<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h3>
<p>AI网关能够捕获每一次交互的完整数据：原始提示词、最终响应、模型选择、Token消耗、调用时延和业务成本等。</p>
<p><strong>统一采集</strong>：所有数据都通过一个标准化的方式汇集。</p>
<p><strong>全面观测</strong>：这些数据可以用于观测，形成对系统性能、成本和用户行为的统一视图。</p>
<p><strong>驱动优化</strong>：通过分析洞察，可以自动优化路由策略、更新缓存内容、或者筛选出有价值的数据用于模型微调，形成一个持续学习、自我完善的闭环。</p>
<p>第6章将详细介绍如何快速构建AI网关，以及API和Agent的货币化。</p>
</div>
</div>
<div class="section" id="id27">
<h2>2.8 运行时<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h2>
<p>开发范式从传统的“标准库与框架”迁移到“AI模型与工具链”。</p>
<div class="section" id="id28">
<h3>2.8.1 什么是AI原生应用的运行时<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>运行时是AI原生应用的核心执行环境。运行时处理的不再是固定的代码，而是充满不确定性的执行计划。核心职责是将模型、工具和数据流有机地整合在一起，不仅要能理解和执行模型生成的动态任务，还要为整个过程提供稳定、高效和安全的保障。</p>
</div>
<div class="section" id="id29">
<h3>2.8.2 运行时的核心挑战<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p><strong>动态逻辑的可靠执行</strong>：运行时需要具备强大的容错和异常处理能力，确保模型生成的动态任务能顺利完成或优雅失败。同时，任务的每一步可能需要不同的依赖库或计算资源，运行时必须能按需、即时地准备执行环境。</p>
<p><strong>海量与实时数据的高效处理</strong>：在RAG等场景下，运行时需要在毫秒级内从海量知识库中检索、处理并传递数据，这对存储I/O和网络延迟提出了极致要求。对于在线学习、实时推荐等场景，运行时还必须具备高效的流式处理能力，确保模型能基于最新的数据进行推理。</p>
<p><strong>异构组件的复杂协同</strong>：AI应用是由模型、向量数据库、外部API工具、多智能体等多个组件构成的，运行时需要提供强大的服务编排和治理能力，并原生支持MCP、A2A等主流交互协议，充当这些组件间的消息总线。</p>
</div>
<div class="section" id="aiserverless">
<h3>2.8.3 面向AI优化的Serverless架构<a class="headerlink" href="#aiserverless" title="Permalink to this headline">¶</a></h3>
<p>以Serverless架构为核心，注入状态管理和性能优化能力。</p>
<p><strong>为无状态的Serverless引入记忆</strong>：通过亲和性调度等机制，将同一会话的多次请求调度到同一个预热实例上，实现状态的就近缓存。</p>
<p><strong>兼顾极致弹性与低延迟</strong>：Serverless按需执行、自动伸缩，轻松应对流量洪峰，并在闲时将成本降至为零。针对延迟敏感的场景，通过预留实例和依赖预加载等技术，可以有效解决冷启动问题，实现毫秒级响应。</p>
<p><strong>让AI工具即插即用</strong>：Serverless函数是承载AI工具的天然载体。每个工具可以封装成一个独立的函数，由智能体按需、事件驱动地调用。</p>
<p>第7章将详细介绍为AI应用和工具提供经济、安全算力的Serverless运行时。</p>
</div>
</div>
<div class="section" id="id30">
<h2>2.9 可观测<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>传统监控主要关注基础设施的性能指标与日志，而AI应用面临着行为不可预测、输出质量波动和成本结构复杂等挑战。一个完成的AI可观测体系应具备3大核心能力：</p>
<ul class="simple">
<li><p>端到端全链路追踪：端到端日志采集和链路追踪，可视化展示请求在AI应用中的执行路径，支持对历史对话的查询与筛选。</p></li>
<li><p>全栈可观测：包含应用、AI网关、推理引擎3个维度，观测内容有实时追踪响应延迟、请求吞吐量、Token消耗，错误率和资源使用情况（如CPU、内存、API令牌）。</p></li>
<li><p>自动化评估功能：引入评估Agent，对应用和模型的输入输出进行自动化的评估，检测幻觉、不一致性或答案质量下降等问题。</p></li>
</ul>
<p>技术集成方面，OpenTelemetry作为行业开放标准，定义了统一的采集规范，使可观测系统能通过自动埋点等方式，无缝接入主流AI框架。数据安全方面，系统必须内置数据脱敏和访问控制等安全机制，确保合规。</p>
<p>第8章将详细介绍AI可观测应具备的3大能力和实现方式。</p>
</div>
<div class="section" id="id31">
<h2>2.10 评估<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<p>传统应用的特点是固定输入必然产生稳定且可复现的输出，而AI应用是非确定性的概率输出，即使输入相同，模型的输出也可能因上下文、训练数据分布或随机性而千差万别。</p>
<div class="section" id="id32">
<h3>2.10.1 构建高质量的数据集<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>第一种是人工构建，评估用例包括标准的问答详情、复杂的多步推理任务，以及那些专门用来测试模型能力边界的边缘场景。第二种是自动化采集，通过对线上系统的观测日志和业务记录进行分析，挖掘出海量的真实用户交互数据。第三种是探索使用AI算法构建数据集，通过大语言模型或其他生成式AI技术，高效创建多样化的测试例，包括复杂场景和对抗样本。</p>
</div>
<div class="section" id="id33">
<h3>2.10.2 明确评估目标<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p><strong>语义评估</strong>：从文本中提取实体、格式、抽象语义（如意图、情绪、主题）等多层次信息，并生成相关问题以深化理解。</p>
<p><strong>Rag评估</strong>：针对从知识库中召回语料的质量进行多维度衡量，包括检索准确性（找到最相关的知识片段）、生成内容可靠（回答不偏离事实）、重复性及多样性等指标。</p>
<p><strong>工具调用评估</strong>：针对需要执行动作的AI原生应用，评估其工具调用的合理性与效率。</p>
<p><strong>端到端Agent评估</strong>：从宏观视角出发，不纠结于具体步骤的详情，只关注Agent是否最终、高效地解决了用户的原始问题，并带来满意的整体体验。</p>
</div>
<div class="section" id="id34">
<h3>2.10.3 搭建完整的自动化评估系统进行评估<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>自动化评估系统需要使用高质量的数据集，优秀的裁判模型，匹配的评估模版，对评估目标进行有效的评估。</p>
<p>评估模版需与评估目标相匹配，比如，在Prompt评估中主要关注识别模糊、歧义或结构不良的输入；在RAG评估中主要衡量检索相关性与生成忠实度；在Tools评估中，则通过参数结构校验与执行结果语义解析，验证工具调用的准确性与理解能力。</p>
<p>自动化评估系统还需要覆盖完整的AI原生应用生命周期。评估的执行应该建立离线与在线相结合的机制。</p>
<ul class="simple">
<li><p>离线评估面向应用迭代周期，
在开发测试阶段对Agent在典型任务、编译案例及对抗性输入下的表现进行全面测试，支持版本间的横向对比与回归分析，确保新版本满足生产上线的要求。</p></li>
<li><p>在线评估则通过小流量灰度发布，在真实生产环境中结合自动化评估器实时生成性能指标。通过与A/B
Test框架相结合，在响应时间、业务效果等关键指标上进行综合对比，为上线决策提供数据支撑。</p></li>
</ul>
<p>第9章将引入全新的评估范式LLM-as-a-Judge，详细阐述如何构建一个高效的自动化评估系统。</p>
</div>
</div>
<div class="section" id="id35">
<h2>2.11 安全<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h2>
<p>AI原生应用的安全防护是一项系统工程，涵盖应用、模型、数据、身份与基础设施五大维度。</p>
<p><strong>AI原生应用的安全</strong>：比如通过提示词注入等手段操控AI应用行为，越权访问导致数据泄露，若基础设施存在漏洞，还有可能引发注入、逆向攻击和算力被滥用等威胁。AI与生俱来的非预期行为以及输出的不可预测性风险，更加加剧了内部治理和合规的挑战。</p>
<p><strong>模型的安全</strong>：输入层对抗样本、提示词注入与恶意文件上传等攻击；推理层模型越狱、RAG知识库爬取与函数调用劫持等风险；输出层可能生成钓鱼信息、虚假建议或传递隐蔽指令。需部署大模型原生安全护栏，作为连接应用与模型之间的可信中间件，提供覆盖全链路的一站式防护，保障输出内容合法可控，并实现AIGC内容可追溯、责任可追，满足监管要求。</p>
<p><strong>数据的安全</strong>：数据收集阶段需完成分类分级与脱敏，防止敏感数据进入训练流程；传输过程采用HTTPS/TLS加密与私有网络隔离，确保通信安全；存储环节通过租户隔离与端到端加密保护数据主权；访问控制需要实现精细化权限管理；访问和使用过程中嵌入AI安全护栏进行实时过滤；删除阶段支持账号注销后的彻底清除与迁移能力，保障用户数据主权。</p>
<p><strong>身份的安全</strong>：事前通过异常访问监测识别风险；事中实施动态权限管理，采用即时授权与细粒度访问控制，遵循最小权限原则；事后通过自动化审计清理僵尸凭证。</p>
<p><strong>基础设施的安全</strong>：构建安全、可控的运行环境，从全局安全态势到计算、网络等细节层面，建立多层次防护体系。</p>
<p>面对动态、自助、多模态的新一代智能体，传统的边界防御已不再适用，必须转向以“纵深防御、动态检测、全程可控”为核心的综合防护体系。</p>
<blockquote>
<div><p>参考资料：</p>
<p><a class="reference external" href="https://developer.aliyun.com/ebook/8479">https://developer.aliyun.com/ebook/8479</a></p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="002003-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html" class="btn btn-neutral float-right" title="【AI白皮书】AI应用开发框架" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="002001-%E3%80%90AI%E7%99%BD%E7%9A%AE%E4%B9%A6%E3%80%91AI%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E6%9E%B6%E6%9E%84.html" class="btn btn-neutral float-left" title="【AI白皮书】AI原生应用及其架构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 测试开发Gang

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>